#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <math.h>

namespace peqs {

    // Threshold, when the recursive function should switch to insertionsort
    #define INSERTION_SORT_THRESH 20

    // Sort two indexes based on the values they are pointing to through a 
    // comparison function
    template<typename iter, typename Compare>
    static inline void sort_indexes(iter *i1, iter *i2, Compare less) {
        iter x = *i1;
        iter y = *i2;
        int c = less(**i1, **i2);
        *i1 = c ? x : y;
        *i2 = c ? y : x;
    }

    // Finds the median of the first, last and middle element between two
    // pointers, places it at the end pointer's position and returns its value
    template<typename iter, typename Compare, typename t>
    t median_of_three(iter low, iter high, Compare less) {

        if (high - low < 2) {
            return *high;
        }

        iter l = low;
        iter m = low + (high - low) / 2;
        iter h = high;

        sort_indexes(&l, &m, less);
        sort_indexes(&m, &h, less);
        sort_indexes(&l, &m, less);

        std::iter_swap(m, high);

        return *high;
    }

    // Calculate a median-of-three of three medians-of-three when both pointers
    // are more than 100 elements apart, and faster median-of-three for smaller
    // ranges
    template<typename iter, typename Compare, typename t>
    t median_of_three_of_median_of_three(iter low, iter high, Compare less) {
        typedef typename std::iterator_traits<iter>::difference_type index;	
        if (high - low < 100) {
            return median_of_three<iter, Compare, t>(low, high, less);
        } else {
            index offset = (high - low) / 8;

            iter a = low;
            iter b = low + offset;
            iter c = low + offset * 2;
            sort_indexes(&a, &b, less);
            sort_indexes(&b, &c, less);
            sort_indexes(&a, &b, less);

            iter d = low + offset * 3;
            iter e = low + offset * 4;
            iter f = low + offset * 5;
            sort_indexes(&d, &e, less);
            sort_indexes(&e, &f, less);
            sort_indexes(&d, &e, less);
            
            iter g = low + offset * 6;
            iter h = low + offset * 7;
            iter i = high;
            sort_indexes(&g, &h, less);
            sort_indexes(&h, &i, less);
            sort_indexes(&g, &h, less);
            
            sort_indexes(&b, &e, less);
            sort_indexes(&e, &h, less);
            sort_indexes(&b, &e, less);

            std::iter_swap(e, high);

            return *high;
        }
    }

    // Performs insertion sort on a range using a comparison function
    template<typename iter, typename Compare>
    void insertion_sort_end(iter low, iter high, Compare less) {
        using t = typename std::iterator_traits<iter>::value_type;
        iter i, j;
        t element;
        for (i = low + 1; i <= high; i++) {
            element = std::move(*i);
            j = i - 1;

            while (j >= low && less(element, *j)) {
                *(j + 1) = std::move(*j);
                j--;
            }
            *(j + 1) = std::move(element);
        }
    }

    // Partitions a range, placing all elements equal to the pivot into the left
    // partition. Branch free for Clang, not branch free for GCC
    template<typename iter, typename Compare>
    iter partition_equal(iter low, iter high, Compare less) {
        using t = typename std::iterator_traits<iter>::value_type;
        t pivot = std::move(*high);
        #if defined(__clang__) || (!defined(__GNUC__) && !defined(__GNUG__))
        iter i = low;
        for (iter j = low; j < high; j++) {
            int c = !less(pivot, *j);
            t y = std::move(*i);
            t z = std::move(*j);
            *i = std::move(c ? z : y);
            *j = std::move(c ? y : z);
            i += c;
        }
        std::iter_swap(i, high);
        return i;
        #else
        iter i = low - 1;
        for (iter j = low; j < high; j++) {
            if (!less(pivot, *j)) {
                i++;
                std::iter_swap(i, j);
            }
        }
        std::iter_swap(i + 1, high);
        return (i + 1);
        #endif
    }

    // Partitions a range, placing all elements equal to the pivot into the right
    // partition. Not branch free. Based on the Lomuto partitioning method
    template<typename iter, typename Compare>
    iter partition_lomuto(iter low, iter high, Compare less) {
        using t = typename std::iterator_traits<iter>::value_type;
        t pivot = std::move(*high);

        iter i = low - 1;
        for (iter j = low; j < high; j++) {
            if (less(*j, pivot)) {
                i++;
                std::iter_swap(i, j);
            }
        }
        std::iter_swap(i + 1, high);
        return (i + 1);
    }

    // Sort a range using a branchy Lomuto partitioning routine
    template<typename iter, typename Compare>
    void sort_lomuto(iter low, iter high, int leftmost, Compare less) {
        using t = typename std::iterator_traits<iter>::value_type;
        if (low < high) {
            if (high - low > INSERTION_SORT_THRESH) {
                t pivot = median_of_three_of_median_of_three<iter, Compare, t>(
                    low, high, less);

                // Check if there are most likely many equal elements and filter 
                // them out first
                if (leftmost || less(*(low - 1), pivot)) {
                    iter new_pivot_index = partition_lomuto(low, high, less);
                    sort_lomuto(low, new_pivot_index - 1, leftmost, less);
                    sort_lomuto(new_pivot_index + 1, high, false, less);
                } else {
                    iter new_pivot_index = partition_equal(low, high, less);
                    sort_lomuto(new_pivot_index + 1, high, false, less);
                }
            } else {
                insertion_sort_end(low, high, less);
            }
        }
    }
    
    // Partitions a range, placing all elements equal to the pivot into the left
    // partition. Branch free for Clang. Falling back to the branch free PDQS
    // partitioning method for GCC
    template<typename iter, typename Compare>
    iter partition_cmov(iter low, iter high, Compare less) {
        using t = typename std::iterator_traits<iter>::value_type;
        #if defined(__clang__) || (!defined(__GNUC__) && !defined(__GNUG__))
        t pivot = *high;
        iter i = low;
        for (iter j = low; j < high; j++) {
            int c = less(*j, pivot);
            t y = std::move(*i);
            t z = std::move(*j);
            *i = std::move(c ? z : y);
            *j = std::move(c ? y : z);
            i += c;
        }
        std::iter_swap(i, high);
        return (i);
        #else
        std::iter_swap(low, high);
        return pdqsort_detail::partition_right_branchless(low, high + 1, less).first;
        #endif
    }

    // Sort a range using a branch free partitioning method
    template<typename iter, typename Compare>
    void sort_cmov(iter low, iter high, int leftmost, Compare less) {
        using t = typename std::iterator_traits<iter>::value_type;
        if (low < high) {
            if (high - low > INSERTION_SORT_THRESH) {
                t pivot = median_of_three_of_median_of_three<iter, Compare, t>(
                    low, high, less);

                // Check if there are most likely many equal elements and filter 
                // them out first
                if (leftmost || less(*(low - 1), pivot)) {
                    iter new_pivot_index = partition_cmov(low, high, less);
                    sort_cmov(low, new_pivot_index - 1, leftmost, less);
                    sort_cmov(new_pivot_index + 1, high, false, less);
                } else {
                    iter new_pivot_index = partition_equal(low, high, less);
                    sort_cmov(new_pivot_index + 1, high, false, less);
                }
                
            } else {
                insertion_sort_end(low, high, less);
            }
        }
    }

    // Performs insertion sort on a range, falling back to branchy quicksort
    // when too many elements are out of place
    template<typename iter, typename Compare>
    void limited_insertion_sort(iter low, iter high, Compare less) {
        using t = typename std::iterator_traits<iter>::value_type;
        iter i, j;
        t element;
        int limit = INSERTION_SORT_THRESH;
        for (i = low + 1; i <= high; i++) {
            element = std::move(*i);
            j = i - 1;

            while (j >= low && less(element, *j)) {
                *(j + 1) = std::move(*j);
                j--;
            }
            *(j + 1) = std::move(element);
            
            if (j < i + 1) {
                limit--;
                if (limit == 0) {
                    sort_lomuto(low, high, true, less);
                    return;
                }
            }
        }
    }

    // Reverses a range
    template<typename iter>
    static inline void reverse(iter low, iter high) {
        for (iter index = low; index < low + (high - low + 1) / 2; index++) {
            std::iter_swap(index, high - index + low);
        }
    }

    // Sort a range of elements accoring to a comparison function
    // Unstable
    template<typename iter, typename Compare>
    void sort(iter low, iter high, Compare less) {
        --high;
        if (low < high) {
            if (high - low > INSERTION_SORT_THRESH) {
                int size = high - low + 1;
                int sample_size = log2(size) * 2.0;

                int offset = size / sample_size;
                int not_ascending = 0;
                int not_descending = 0;

                for (iter index = low; index < high; index += offset) {
                    not_ascending += less(*(index + 1), *index);
                    not_descending += less(*index, *(index + 1));
                }

                // No pattern on the small sample size likely means no pattern 
                // on the full array
                if (not_ascending > 1 && 
                        not_descending > 1 && 
                        not_ascending < sample_size - 1 && 
                        not_descending < sample_size - 1) {
                    sort_cmov(low, high, true, less);
                } else {
                    not_ascending = 0;
                    not_descending = 0;
                    
                    for (iter index = low; index < high; index++) {
                        not_ascending += less(*(index + 1), *index);
                        not_descending += less(*index, *(index + 1));
                    }
                    
                    if (not_ascending == 0) {
                    } else
                    if (not_ascending < log(size)) {
                        limited_insertion_sort(low, high, less);
                    } else if (not_ascending < 0.15 * size) {
                        sort_lomuto(low, high, true, less);
                    } else if (not_descending == 0) {
                        reverse(low, high);
                    } else if (not_descending < log(size)) {
                        reverse(low, high);
                        limited_insertion_sort(low, high, less);
                    } else if (not_descending < 0.15 * size) {
                        reverse(low, high);
                        sort_lomuto(low, high, true, less);
                    } else {
                        sort_cmov(low, high, true, less);
                    }
                }
            } else {
                insertion_sort_end(low, high, less);
            }
        }
    }
}