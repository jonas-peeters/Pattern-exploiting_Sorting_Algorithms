
#include "blockquick.h"
#include "data-random.h"
#include "insertionssort.h"
#include "heapsort.h"
#include "heapsorto.h"
#include "median.h"
#include "mergeo.h"
#include "mergeu.h"
#include "minmax.h"
#include "quicko.h"
#include "quickodualpivot.h"
#include "quickomulti.h"
#include "quickomultiinplace.h"
#include "quickomultix4.h"
#include "quickomultix4inplace.h"
#include "quickosimd.h"
#include "quickosimple.h"
#include "quickostable.h"
#include "quickoswaparith.h"
#include "quickoswaparray.h"
#include "quickoswapasm.h"
#include "quickoswapcmov.h"
#include "quickotuned.h"
#include "quickuhoare.h"
#include "quickulomuto.h"
#include "simd.h"
#include "swap.h"
#include "const.h"

#include "papi.h"

#include <math.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <x86intrin.h>

#define SEEDS_AMOUNT 50
#define MIN_RUNS_PER_BENCH 3
#define MAX_RUNS_PER_BENCH 10

enum before_sort_actions {
  NOTHING,
  SORT,
  SORT_99,
  SORT_95,
  SORT_90,
  SORT_80,
  SORT_50,
  SORT_REVERSE,
  LIMIT_VALUES_1000,
  LIMIT_VALUES_10000
};

struct Algorithm {
  char name[50];
  void (*sorting_function) (int *, int64_t, int64_t);
};

struct BeforeSortAction {
  char name[50];
  int action;
};

int compare_ints (const void *a, const void *b){
  const int *da = (const int *) a;
  const int *db = (const int *) b;
  return (*da > *db) - (*da < *db);
}

void qsort_h(int* array, int64_t low, int64_t high) {
  qsort(&array[low], high - low + 1, sizeof (int), compare_ints);
}

void handle_error(int retval) {
  if (retval != PAPI_OK) {
    printf("PAPI error %d: %s\n", retval, PAPI_strerror(retval));
    exit(1);
  }
}

void shuffle(int *array, int low, int high, float percentage, int seed) {
  srand(seed + 1000);
  float percent_to_shuffle = percentage / 2;
  int size = high - low + 1;
  int offset = size / (percent_to_shuffle * size);
  for (int i = 0; i < size - offset; i += offset) {
    int r1 = rand() % size;
    int r2 = rand() % offset;
    swap(&array[i + r2], &array[r1]);
  }
};

// Args
// 1. Algorithm name
// 2. Before sort action
// 3. Array Size
// 4. Seed
int main(int argc, char *argv[]) {
  printf("Starting\n");
  
  int seeds[SEEDS_AMOUNT];
  for (int i = 0; i < SEEDS_AMOUNT; i++) {
    seeds[i] = i;
  }

  int array_sizes[] = {3, 5, 7, 10, 15, 20, 25, 30, 40, 50, 100, 1000, 10000, 100000};
  struct Algorithm algorithms[] = {
    {"Quicksort Std Lomuto ", sort_quick_lomuto},
    {"Quicksort Std Hoare  ", sort_quick_hoare},
    {"Quicksort Optimized 1", sort_quick_optimized},
    {"Quicksort SIMD       ", sort_quick_simd},
    {"Quicksort Swap Arith ", sort_quick_optimized_swap_arith},
    {"Quicksort Swap CMOV  ", sort_quick_optimized_swap_cmov},
    {"Quicksort Swap Array ", sort_quick_optimized_swap_array},
    {"Quicksort Swap ASM   ", sort_quick_optimized_swap_asm},
    //{"Quickosrt Multi x8", sort_quick_multi},
    //{"Quicksort Multi x4", sort_quick_multix4},
    //{"Quicksort Multi x8 Inplace", sort_quick_multi_inplace},
    //{"Quicksort Multi x4 Inplace", sort_quick_multi_x4_inplace},
    //{"Quicksort Dual Pivot", sort_quick_optimized_dual},
    {"Quicksort Stable     ", sort_quick_stable},
    {"BlockQuicksort      1", sort_quick_block},
    {"Mergesort Standard   ", sort_merge_standard},
    {"Mergesort Optimized  ", sort_merge_optimized},
    {"Heapsort Standard    ", heapsort},
    {"Heapsort Optimized   ", heapsorto},
    {"Insertionsort        ", insertionSortStd},
    {"Insertionsort Opt    ", insertionSortStdOpt},
    {"Quicksort tuned      ", sort_quick_tuned},
    {"Quicksort libc       ", qsort_h}
  };

  struct BeforeSortAction before_sort_actions[] = {
    {"NOTHING", NOTHING}, 
    {"SORT", SORT}, 
    {"SORT_99", SORT_99}, 
    {"SORT_95", SORT_95}, 
    {"SORT_90", SORT_90}, 
    {"SORT_80", SORT_80}, 
    {"SORT_50", SORT_50}, 
    {"SORT_REVERSE", SORT_REVERSE}, 
    {"LIMIT_VALUES_1000", LIMIT_VALUES_1000}, 
    {"LIMIT_VALUES_10000", LIMIT_VALUES_10000}
  };


  

  int cpu_counters[] = {
    PAPI_BR_CN, 
    PAPI_BR_MSP, 
    PAPI_TOT_CYC, 
    PAPI_REF_CYC,
    PAPI_L1_DCM
  };

  int CPU_COUNTER_COUNT = sizeof(cpu_counters) / sizeof(*cpu_counters);
  int event_set = PAPI_NULL;
  int version = PAPI_library_init(PAPI_VER_CURRENT);
  handle_error(PAPI_create_eventset(&event_set));
  for (int i = 0; i < CPU_COUNTER_COUNT; i++) {
    handle_error(PAPI_add_event(event_set, cpu_counters[i]));
  }
  handle_error(PAPI_start(event_set));


  FILE *file;
  file = fopen("output.csv", "w");

  fprintf(file, "Algorithm,Array size,Pre sort action,Average,Time per Element,Std Dev");

  for (int i = 0; i < CPU_COUNTER_COUNT; i++) {
    PAPI_event_info_t info;
    handle_error(PAPI_get_event_info(cpu_counters[i], &info));
    fprintf(file, ",%s", info.long_descr);
  }
  for (int i = 0; i < SEEDS_AMOUNT; i++) {
    fprintf(file, ",Seed %d", i);
  }
  fprintf(file, "\n");


  for (int algo_index = 0; algo_index < sizeof(algorithms) / sizeof(algorithms[0]); algo_index++) {
    float last_mean = 0;
    float runs_of_size = 0;

    struct Algorithm algorithm = algorithms[algo_index];
    if (argc > 1) {
      if (!strstr(algorithm.name, argv[1]) && !strstr("*", argv[1])) {
        continue;
      }
    }

    for (int action_index = 0; action_index < sizeof(before_sort_actions) / sizeof(before_sort_actions[0]); action_index++) {          
      struct BeforeSortAction before_sort_action_struct = before_sort_actions[action_index];
      if (argc > 2) {
        if (!strstr("*", argv[2])) {
          if (action_index != 0) {
            continue;
          }
          before_sort_action_struct = before_sort_actions[atoi(argv[2])];
        }
      }
      int before_sort_action = before_sort_action_struct.action;
      for (int size_index = 0; size_index < sizeof(array_sizes) / sizeof(array_sizes[0]); size_index++) {
        int array_size = array_sizes[size_index];
        if (argc > 3) {
          if (size_index != 0) {
            continue;
          }
          array_size = atoi(argv[3]);
        }

        // Insertionsort on shuffled arrays just takes way to long for large sizes
        if (strstr(algorithm.name, "Insertionsort") && array_size >= 100000) {
          continue;
        }

        runs_of_size = 0;
        last_mean = 0;

        double *seed_times = (double *) malloc(sizeof(double) * SEEDS_AMOUNT);
        double *event_values_of_row = (double *) malloc(sizeof(double) * sizeof(cpu_counters) / sizeof(*cpu_counters));
        for (int i = 0; i < CPU_COUNTER_COUNT; i++) {
          event_values_of_row[i] = 0;
        }

        for (int seed_index = 0; seed_index < SEEDS_AMOUNT; seed_index++) {
          int seed = seeds[seed_index];
          if (argc > 4) {
            if (seed_index != 0) {
              continue;
            }
            seed = atoi(argv[4]);
          }
        

          int *dataset = (int *) malloc(sizeof(int) * array_size);
          fill_random(dataset, array_size, seed);

          if (before_sort_action == SORT) {
            sort_quick_optimized_h(dataset, 0, array_size - 1);
          } else if (before_sort_action == SORT_99) {
            sort_quick_optimized_h(dataset, 0, array_size - 1);
            shuffle(dataset, 0, array_size - 1, 0.0001, seed);
          } else if (before_sort_action == SORT_95) {
            sort_quick_optimized_h(dataset, 0, array_size - 1);
            shuffle(dataset, 0, array_size - 1, 0.05, seed);
          } else if (before_sort_action == SORT_90) {
            sort_quick_optimized_h(dataset, 0, array_size - 1);
            shuffle(dataset, 0, array_size - 1, 0.1, seed);
          } else if (before_sort_action == SORT_80) {
            sort_quick_optimized_h(dataset, 0, array_size - 1);
            shuffle(dataset, 0, array_size - 1, 0.2, seed);
          } else if (before_sort_action == SORT_50) {
            sort_quick_optimized_h(dataset, 0, array_size - 1);
            shuffle(dataset, 0, array_size - 1, 0.5, seed);
          } else if (before_sort_action == SORT_REVERSE) {
            sort_quick_optimized_h(dataset, 0, array_size - 1);
            for (int i = 0; i < array_size / 2; i++) {
              swap(&dataset[i], &dataset[array_size - 1 - i]);
            }
          } else if (before_sort_action == LIMIT_VALUES_1000) {
            for (int i = 0; i < array_size; i++) {
              dataset[i] = dataset[i] % 1000;
            }
          } else if (before_sort_action == LIMIT_VALUES_10000) {
            for (int i = 0; i < array_size; i++) {
              dataset[i] = dataset[i] % 10000;
            }
          }
          int *data_to_sort = (int *) malloc(sizeof(int) * array_size);

          clock_t total = 0;
          int runs = 0;
          long long int *event_values_of_seed = (long long int *) malloc(sizeof(long long int) * sizeof(cpu_counters) / sizeof(*cpu_counters));
          for (int i = 0; i < CPU_COUNTER_COUNT; i++) {
            event_values_of_seed[i] = 0;
          }

          while ((total < 10000000 || runs < MIN_RUNS_PER_BENCH) && runs < MAX_RUNS_PER_BENCH) {
            printf("\r");
            printf("Benching %s with size %d, action %s and seed %d", algorithm.name, array_size, before_sort_action_struct.name, seed);
            fflush(stdout);

            for (int i = 0; i < array_size; i++) {
              data_to_sort[i] = dataset[i];
            }
           
            handle_error(PAPI_reset(event_set));
            uint64_t start = __rdtsc();
            algorithm.sorting_function(data_to_sort, 0, array_size - 1);
            uint64_t stop = __rdtsc();
            total += (stop - start);
            handle_error(PAPI_accum(event_set, event_values_of_seed));

            // Verify integrity
            for (int i = 0; i < array_size - 1; i++) {
              if (data_to_sort[i] > data_to_sort[i + 1]) {
                printf("\nIntegrity violation!\n");
                for (int index = 0; index < array_size; index++) {
                  printf("%d ", data_to_sort[index]);
                }
                printf("\n");
                exit(1);
              }
            }
            runs++;
          }

          free(dataset);
          free(data_to_sort);

          seed_times[seed_index] = (double)(total) / CLOCKS_PER_SEC * 1000 / runs;
          for (int i = 0; i < CPU_COUNTER_COUNT; i++) {
            event_values_of_row[i] = ((double) event_values_of_seed[i]) / (double) runs;
          }
          free(event_values_of_seed);
        }

        fprintf(file, "%s,%d,%s", algorithm.name, array_size, before_sort_action_struct.name);

        double seeds_total = 0;
        for (int index = 0; index < SEEDS_AMOUNT; index++) {
          seeds_total += seed_times[index];
        }
        float mean = seeds_total / SEEDS_AMOUNT;

        last_mean += mean;
        runs_of_size++;
        float sum = 0;
        for (int index = 0; index < SEEDS_AMOUNT; index++) {
          float diff = mean - seed_times[index];
          float square = powf(diff, 2);
          sum += square; 
        }
        float std_dev = sqrtf(sum / (float)SEEDS_AMOUNT);
        fprintf(file, ",%f", mean);
        fprintf(file, ",%f", mean / array_size);
        fprintf(file, ",%f", std_dev);
        for (int index = 0; index < CPU_COUNTER_COUNT; index++) {
          fprintf(file, ",%f", event_values_of_row[index]);
        }
        for (int index = 0; index < SEEDS_AMOUNT; index++) {
          fprintf(file, ",%f", seed_times[index]);
        }
        fprintf(file, "\n");
        free(seed_times);
        free(event_values_of_row);
      }

      if (runs_of_size != 0) {
        printf("  Average: %.3f\n", last_mean / runs_of_size);
      }
    }
    
  }
}
