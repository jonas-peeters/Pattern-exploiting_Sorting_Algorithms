
#include "blockquick.h"
#include "data-random.h"
#include "insertionssort.h"
#include "heapsort.h"
#include "heapsorto.h"
#include "median.h"
#include "mergeo.h"
#include "mergeu.h"
#include "mergeinplace.h"
#include "minmax.h"
#include "quicko.h"
#include "quickodualpivot.h"
#include "quickomulti.h"
#include "quickomultiinplace.h"
#include "quickomultix4.h"
#include "quickomultix4inplace.h"
#include "quickosimd.h"
#include "quickosimple.h"
#include "quickostable.h"
#include "quickoswaparith.h"
#include "quickoswaparray.h"
#include "quickoswapasm.h"
#include "quickoswapcmov.h"
#include "quickotuned.h"
#include "quickuhoare.h"
#include "quickulomuto.h"
#include "simd.h"
#include "swap.h"
#include "const.h"

#include "papi.h"

#include <math.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <x86intrin.h>

#define SEEDS_AMOUNT 10
#define MIN_RUNS_PER_BENCH 3
#define MAX_RUNS_PER_BENCH 500

enum before_sort_actions {
  NOTHING,
  PRESORTED,
  SORT_REVERSE,
  END_RANDOM,
  LIMIT_VALUES_1000,
  LIMIT_VALUES_10000
};

struct Algorithm {
  char name[50];
  void (*sorting_function) (int *, int, int);
};

struct BeforeSortAction {
  char name[50];
  int action;
};

int compare_ints (const void *a, const void *b){
  const int *da = (const int *) a;
  const int *db = (const int *) b;
  return (*da > *db) - (*da < *db);
}

void qsort_h(int* array, int low, int high) {
  qsort(&array[low], high - low + 1, sizeof (int), compare_ints);
}

void handle_error(int retval) {
  if (retval != PAPI_OK) {
    printf("PAPI error %d: %s\n", retval, PAPI_strerror(retval));
    exit(1);
  }
}

// Args
// 1. Algorithm name
// 2. Before sort action
// 3. Array Size
// 4. Seed
int main(int argc, char *argv[]) {
  printf("Starting\n");
  
  int seeds[SEEDS_AMOUNT];
  for (int i = 0; i < SEEDS_AMOUNT; i++) {
    seeds[i] = i;
  }

  int array_sizes[] = {3, 5, 7, 10, 15, 20, 25, 30, 40, 50, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000};
  struct Algorithm algorithms[] = {
    {"Quicksort Std Lomuto ", sort_quick_lomuto},
    {"Quicksort Std Hoare  ", sort_quick_hoare},
    {"Quicksort Optimized  ", sort_quick_optimized},
    //{"Quicksort SIMD       ", sort_quick_simd},
    {"Quicksort Swap Arith ", sort_quick_optimized_swap_arith},
    {"Quicksort Swap CMOV  ", sort_quick_optimized_swap_cmov},
    {"Quicksort Swap Array ", sort_quick_optimized_swap_array},
    {"Quicksort Swap ASM   ", sort_quick_optimized_swap_asm},
    //{"Quickosrt Multi x8", sort_quick_multi},
    //{"Quicksort Multi x4", sort_quick_multix4},
    //{"Quicksort Multi x8 Inplace", sort_quick_multi_inplace},
    //{"Quicksort Multi x4 Inplace", sort_quick_multi_x4_inplace},
    //{"Quicksort Dual Pivot", sort_quick_optimized_dual},
    {"Quicksort Stable     ", sort_quick_stable},
    {"BlockQuicksort       ", sort_quick_block},
    //{"Mergesort Standard   ", sort_merge_standard},
    //{"Mergesort Optimized  ", sort_merge_optimized},
    {"Mergesort Inplace    ", sort_merge_inplace},
    //{"Heapsort Standard    ", heapsort},
    //{"Heapsort Optimized   ", heapsorto},
    //{"Insertionsort        ", insertionSortStd},
    //{"Insertionsort Opt    ", insertionSortStdOpt},
    {"Quicksort tuned      ", sort_quick_tuned},
    {"Quicksort libc       ", qsort_h}
  };

  struct BeforeSortAction before_sort_actions[] = {
    {"NOTHING", NOTHING},
    {"PRESORTED", PRESORTED},
    {"SORT_REVERSE", SORT_REVERSE},
    {"END_RANDOM", END_RANDOM},
    {"LIMIT_VALUES_1000", LIMIT_VALUES_1000},
    {"LIMIT_VALUES_10000", LIMIT_VALUES_10000}
  };

  float randomnes[] = {0.0, 0.00001, 0.0001, 0.001, 0.005, 0.01, 0.05, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9};

  int cpu_counters[] = {
    PAPI_BR_CN, 
    PAPI_BR_MSP, 
    PAPI_TOT_CYC, 
    PAPI_REF_CYC,
    PAPI_L1_DCM
  };

  int CPU_COUNTER_COUNT = sizeof(cpu_counters) / sizeof(*cpu_counters);
  int event_set = PAPI_NULL;
  int version = PAPI_library_init(PAPI_VER_CURRENT);
  handle_error(PAPI_create_eventset(&event_set));
  for (int i = 0; i < CPU_COUNTER_COUNT; i++) {
    handle_error(PAPI_add_event(event_set, cpu_counters[i]));
  }
  handle_error(PAPI_start(event_set));


  FILE *file;
  file = fopen("output.csv", "w");

  fprintf(file, "Algorithm,Array size,Pre bench action,Randomnes,Average Cycles,Cycles per Element,Std Dev");

  for (int i = 0; i < CPU_COUNTER_COUNT; i++) {
    PAPI_event_info_t info;
    handle_error(PAPI_get_event_info(cpu_counters[i], &info));
    fprintf(file, ",%s", info.long_descr);
  }
  for (int i = 0; i < SEEDS_AMOUNT; i++) {
    fprintf(file, ",Seed %d", i);
  }
  fprintf(file, "\n");


  for (int algo_index = 0; algo_index < sizeof(algorithms) / sizeof(algorithms[0]); algo_index++) {
    float last_mean = 0;
    float runs_of_size = 0;

    struct Algorithm algorithm = algorithms[algo_index];
    if (argc > 1) {
      if (!strstr(algorithm.name, argv[1]) && !strstr("*", argv[1])) {
        continue;
      }
    }

    for (int action_index = 0; action_index < sizeof(before_sort_actions) / sizeof(before_sort_actions[0]); action_index++) {          
      struct BeforeSortAction before_sort_action_struct = before_sort_actions[action_index];
      if (argc > 2) {
        if (!strstr("*", argv[2])) {
          if (action_index != 0) {
            continue;
          }
          before_sort_action_struct = before_sort_actions[atoi(argv[2])];
        }
      }
      int before_sort_action = before_sort_action_struct.action;

      for (int randomnes_index = 0; randomnes_index < sizeof(randomnes) / sizeof(randomnes[0]); randomnes_index++) {
        if (before_sort_action != PRESORTED && before_sort_action != END_RANDOM && randomnes_index != 0) {
          continue;
        }
        float randomnes_value = randomnes[randomnes_index];

        for (int size_index = 0; size_index < sizeof(array_sizes) / sizeof(array_sizes[0]); size_index++) {
          int array_size = array_sizes[size_index];
          if (argc > 3) {
            if (size_index != 0) {
              continue;
            }
            array_size = atoi(argv[3]);
          }

          if ((before_sort_action > 2 && array_size > 10000000) ||
            (before_sort_action == 1 && randomnes_index != 0 && array_size > 10000000)
          ) {
            continue;
          }

          // Insertionsort on shuffled arrays just takes way to long for large sizes
          if (strstr(algorithm.name, "Insertionsort") && array_size >= 100000) {
            continue;
          }

          runs_of_size = 0;
          last_mean = 0;

          double *seed_times = (double *) calloc(SEEDS_AMOUNT, sizeof(double));
          double *event_values_of_row = (double *) calloc(sizeof(cpu_counters) / sizeof(*cpu_counters), sizeof(double));

          int seeds_performed = 0;
          double seeds_total = 0;

          for (int seed_index = 0; seed_index < SEEDS_AMOUNT; seed_index++) {
            int seed = seeds[seed_index];
            if (argc > 4) {
              if (seed_index != 0) {
                continue;
              }
              seed = atoi(argv[4]);
            }
            seeds_performed++;
          

            int *dataset = (int *) malloc(sizeof(int) * array_size);
            
            fill_random(dataset, array_size, seed);

            if (before_sort_action == PRESORTED) {
              sort_quick_optimized(dataset, 0, array_size - 1);
              randomise(dataset, 0, array_size - 1, randomnes_value, seed);
            } else if (before_sort_action == END_RANDOM) {
              sort_quick_optimized(dataset, 0, (array_size - 1) * (1 - randomnes_value));
            } else if (before_sort_action == SORT_REVERSE) {
              sort_quick_optimized(dataset, 0, array_size - 1);
              for (int i = 0; i < array_size / 2; i++) {
                swap(&dataset[i], &dataset[array_size - 1 - i]);
              }
            } else if (before_sort_action == LIMIT_VALUES_1000) {
              for (int i = 0; i < array_size; i++) {
                dataset[i] = dataset[i] % 1000;
              }
            } else if (before_sort_action == LIMIT_VALUES_10000) {
              for (int i = 0; i < array_size; i++) {
                dataset[i] = dataset[i] % 10000;
              }
            }
            int *sorted_dataset = (int *) malloc(sizeof(int) * array_size);
            int *data_to_sort = (int *) malloc(sizeof(int) * array_size);

            for (int i = 0; i < array_size; i++) {
              sorted_dataset[i] = dataset[i];
            }
            sort_quick_optimized(sorted_dataset, 0, array_size - 1);

            //printf("\n");
            //for (int i = 1; i < array_size - 1; i++) {
            //  if (dataset[i] > dataset[i + 1]) {
            //    printf("%d\t", i);
            //  }
            //}
            //printf("\n");

            clock_t total = 0;
            int runs = 0;
            long long int *event_values_of_seed = (long long int *) malloc(sizeof(long long int) * sizeof(cpu_counters) / sizeof(*cpu_counters));
            for (int i = 0; i < CPU_COUNTER_COUNT; i++) {
              event_values_of_seed[i] = 0;
            }

            while ((total < 10000000 || runs < MIN_RUNS_PER_BENCH) && runs < MAX_RUNS_PER_BENCH) {
              printf("\r");
              printf("Benching %s with size %d, action %s, randomnes %f and seed %d", algorithm.name, array_size, before_sort_action_struct.name, randomnes_value, seed);
              fflush(stdout);

              for (int i = 0; i < array_size; i++) {
                data_to_sort[i] = dataset[i];
              }
            
              handle_error(PAPI_reset(event_set));
              //uint start = __rdtsc();
              algorithm.sorting_function(data_to_sort, 0, array_size - 1);
              //uint stop = __rdtsc();
              //total += (stop - start);
              handle_error(PAPI_accum(event_set, event_values_of_seed));
              total = event_values_of_seed[2];

              // Verify integrity
              for (int i = 0; i < array_size - 1; i++) {
                if (data_to_sort[i] > data_to_sort[i + 1]) {
                  printf("\nIntegrity violation!\n");
                  for (int index = i - 1; index < i + 2; index++) {
                    printf("%d:%d ", index, data_to_sort[index]);
                  }
                  printf("\n");
                  exit(1);
                }
                if (data_to_sort[i] != sorted_dataset[i]) {
                  printf("\nIntegrity violation! Wrqng value at %d\n", i);
                  exit(1);
                }
              }
              runs++;

              if (total > 75000000000)
                break;
            }

            free(dataset);
            free(data_to_sort);
            free(sorted_dataset);

            seed_times[seed_index] = (double)(total) / runs;
            for (int i = 0; i < CPU_COUNTER_COUNT; i++) {
              event_values_of_row[i] = ((double) event_values_of_seed[i]) / (double) runs;
            }
            free(event_values_of_seed);


            seeds_total = 0;
            for (int index = 0; index < seeds_performed; index++) {
              seeds_total += seed_times[index];
            }

            if (total > 75000000000) {
                printf("  Abort %s as it takes too long! ", algorithm.name);
                break;
            }
            
            if (seeds_total > 750000000000) {
              printf("  Abort %s as it takes too long! ", algorithm.name);
              break;
            }
          }

          fprintf(file, "%s,%d,%s,%f", algorithm.name, array_size, before_sort_action_struct.name, before_sort_action == PRESORTED || before_sort_action == END_RANDOM ? randomnes_value : -1);
          
          float mean = seeds_total / seeds_performed;

          last_mean += mean;
          runs_of_size++;
          float sum = 0;
          for (int index = 0; index < seeds_performed; index++) {
            float diff = mean - seed_times[index];
            float square = powf(diff, 2);
            sum += square; 
          }
          float std_dev = sqrtf(sum / (float)seeds_performed);
          fprintf(file, ",%f", mean);
          fprintf(file, ",%f", mean / array_size);
          fprintf(file, ",%f", std_dev);
          for (int index = 0; index < CPU_COUNTER_COUNT; index++) {
            fprintf(file, ",%f", event_values_of_row[index] / seeds_performed);
          }
          for (int index = 0; index < seeds_performed; index++) {
            fprintf(file, ",%f", seed_times[index]);
          }
          fprintf(file, "\n");
          free(seed_times);
          free(event_values_of_row);
          fflush(file);

          if (seeds_total > 750000000000) {
              printf("  Abort %s as it takes too long! ", algorithm.name);
              break;
            }
        }

        if (runs_of_size != 0) {
          printf("  Average: %.3f\n", last_mean / runs_of_size);
        }
      }
    }
  }
}
