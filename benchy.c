
#include "blockquick.h"
#include "data-random.h"
#include "insertionssort.h"
#include "heapsort.h"
#include "heapsorto.h"
#include "median.h"
#include "mergeo.h"
#include "mergeu.h"
#include "minmax.h"
#include "quicko.h"
#include "quickodualpivot.h"
#include "quickomulti.h"
#include "quickomultiinplace.h"
#include "quickomultix4.h"
#include "quickomultix4inplace.h"
#include "quickosimd.h"
#include "quickosimple.h"
#include "quickostable.h"
#include "quickoswaparith.h"
#include "quickoswaparray.h"
#include "quickoswapasm.h"
#include "quickoswapcmov.h"
#include "quickotuned.h"
#include "quickuhoare.h"
#include "quickulomuto.h"
#include "simd.h"
#include "swap.h"
#include "timsort.h"
#include "const.h"

#include <math.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <x86intrin.h>

#define DATA_AMOUNT 2000000
#define MIN_RUNS_PER_BENCH 3
#define MAX_RUNS_PER_BENCH 10

enum before_sort_actions {
  NOTHING,
  SORT,
  SORT_REVERSE,
  LIMIT_VALUES_1000,
  LIMIT_VALUES_10000
};

int original_data[DATA_AMOUNT];

void shuffle_data(int data_to_sort[], int size) {
  size_t i;
  for (i = 0; i < size; i++) {
    size_t j = (i + rand()) % size;
    int t = data_to_sort[j];
    data_to_sort[j] = data_to_sort[i];
    data_to_sort[i] = t;
    //data_to_sort[i] = original_data[i];
  }
}

float individual_times[MAX_RUNS_PER_BENCH];
float reference_value = 0;

void bench(char name[], void (*fun)(int *, int64_t, int64_t), int array_size,
           int data_to_sort[]) {

  if (array_size == -1) {
    printf("%s", name);
    return;
  }  

  // printf("Testing %s with array size %d: ", name, array_size);

  clock_t total = 0;
  int runs = 0;
  while ((total < 400000000 || runs < MIN_RUNS_PER_BENCH) &&
         runs < MAX_RUNS_PER_BENCH) {
    runs++;
    shuffle_data(data_to_sort, array_size);
    // struct timespec start, stop;
    uint64_t start = __rdtsc();
    fun(data_to_sort, 0, array_size - 1);
    uint64_t stop = __rdtsc();
    total += (stop - start);
    individual_times[runs - 1] = (float)(stop - start) / CLOCKS_PER_SEC * 1000;

    /*if (runs == 1 && array_size == 10) {
      printf("\n");
      for (int i = 0; i < array_size; i++) {
        printf("%d ", data_to_sort[i]);
      }
      printf("\n");
    }*/

    if (runs == 1) {
      for (int index = 0; index < array_size - 1; index++) {
        if (data_to_sort[index] > data_to_sort[index + 1]) {
          printf("\nArray\n");
          for (int64_t pindex = 0; pindex <= min(index + 4, array_size); pindex++) {
            printf("%d ", data_to_sort[pindex]);
          }
          // printf("\n");

          printf("Integrity check failed for %s at index %d\n", name,
                 index + 1);
          exit(1);
        }
      }
    }
  }

  float mean = (float)(total)*1000 / CLOCKS_PER_SEC / runs;
  float sum = 0;
  for (int index = 0; index < runs; index++) {
    float diff = mean - individual_times[index];
    float square = powf(diff, 2);
    sum += square;
  }
  float std_dev = sqrtf(sum / (float)runs);

  if (reference_value == 0) {
    reference_value = mean;
  }

  char *output = (char *)malloc(20 * sizeof(char));
  sprintf(output, "                   ");
  //sprintf(output, "%.2f±%.2f", mean, std_dev);
  if (mean < 1) {
    sprintf(output, "%.2f±%.2f %.0f%%", mean, std_dev, mean / reference_value * 100);
  } else if (mean < 10) {
    sprintf(output, "%.1f±%.1f %.0f%%", mean, std_dev, mean / reference_value * 100);
  } else {
    sprintf(output, "%.0f±%.0f %.0f%%", mean, std_dev, mean / reference_value * 100);
  }

  for (int index = 0; index < 20; index++) {
    if (output[index] == '\0') {
      output[index] = ' ';
    }
  }
  printf("%s", output);

  free(output);
}

/*void bench_min_max(int(fun)(int, int)) {

  clock_t total = 0;
  for (int i = 0; i < RUNS_PER_BENCH; i++) {
    clock_t start = clock();
    shuffle_data(10);
    int x = data_to_sort[4];
    int y = data_to_sort[7];
    int z = fun(x, y);
    clock_t stop = clock();
    data_to_sort[2] = z;
    total += stop - start;
  }

  float msec = (float)(total)*1000000 / CLOCKS_PER_SEC / RUNS_PER_BENCH;

  printf("Microseconds: %.3f\n", msec);
}*/

struct Algorithm {
  char name[50];
  void (*sorting_function) (int *, int64_t, int64_t);
};

int compare_ints (const void *a, const void *b){
  const int *da = (const int *) a;
  const int *db = (const int *) b;
  return (*da > *db) - (*da < *db);
}

void qsort_h(int* array, int64_t low, int64_t high) {
  qsort(&array[low], high - low + 1, sizeof (int), compare_ints);
}

// Args
// 1. Algorithm name
// 2. Array Size
// 3. Before sort action
// 4. Seed
int main(int argc, char *argv[]) {
  printf("Starting\n");
  
  int seeds[50];
  for (int i = 0; i < 50; i++) {
    seeds[i] = i;
  }

  int array_sizes[] = {3, 5, 7, 10, 15, 20, 25, 30, 40, 50, 100, 1000, 10000, 100000};
  struct Algorithm algorithms[] = {
    {"Quicksort Std Lomuto ", sort_quick_lomuto},
    {"Quicksort Std Hoare  ", sort_quick_hoare},
    {"Quicksort Optimized  ", sort_quick_optimized},
    {"Quicksort SIMD       ", sort_quick_simd},
    {"Quicksort Swap Arith ", sort_quick_optimized_swap_arith},
    {"Quicksort Swap CMOV  ", sort_quick_optimized_swap_cmov},
    {"Quicksort Swap Array ", sort_quick_optimized_swap_array},
    {"Quicksort Swap ASM   ", sort_quick_optimized_swap_asm},
    //{"Quickosrt Multi x8", sort_quick_multi},
    //{"Quicksort Multi x4", sort_quick_multix4},
    //{"Quicksort Multi x8 Inplace", sort_quick_multi_inplace},
    //{"Quicksort Multi x4 Inplace", sort_quick_multi_x4_inplace},
    //{"Quicksort Dual Pivot", sort_quick_optimized_dual},
    {"Quicksort Stable     ", sort_quick_stable},
    {"BlockQuicksort       ", sort_quick_block},
    {"Mergesort Standard   ", sort_merge_standard},
    {"Mergesort Optimized  ", sort_merge_optimized},
    {"Heapsort Standard    ", heapsort},
    {"Heapsort Optimized   ", heapsorto},
    {"Insertionsort        ", insertionSortStd},
    {"Quicksort tuned      ", sort_quick_tuned},
    {"Quicksort libc       ", qsort_h}
  };

  int before_sort_actions[] = {NOTHING, SORT, SORT_REVERSE, LIMIT_VALUES_1000, LIMIT_VALUES_10000};

  FILE *file;
  file = fopen("output.csv", "w");

  fprintf(file, "Algorithm,Array size,Seed,Pre sort action,Runs,Average,Time per Element,Std Dev\n");

  for (int algo_index = 0; algo_index < sizeof(algorithms) / sizeof(algorithms[0]); algo_index++) {
    float last_mean = 0;
    float runs_of_size;
    for (int size_index = 0; size_index < sizeof(array_sizes) / sizeof(array_sizes[0]); size_index++) {
      runs_of_size = 0;
      for (int seed_index = 0; seed_index < sizeof(seeds) / sizeof(seeds[0]); seed_index++) {
        for (int action_index = 0; action_index < sizeof(before_sort_actions) / sizeof(before_sort_actions[0]); action_index++) {
          struct Algorithm algorithm = algorithms[algo_index];
          int array_size = array_sizes[size_index];
          int seed = seeds[seed_index];
          int before_sort_action = before_sort_actions[action_index];

          if (strstr(algorithm.name, "Insertionsort") && array_size >= 100000) {
            continue;
          }

          if (argc > 1) {
            if (!strstr(algorithm.name, argv[1])) {
              continue;
            }
          }
          if (argc > 2) {
            if (size_index != 0) {
              continue;
            }
            array_size = atoi(argv[2]);
          }
          if (argc > 3) {
            if (action_index != 0) {
              continue;
            }
            before_sort_action = atoi(argv[3]);
          }
          if (argc > 4) {
            if (seed_index != 0) {
              continue;
            }
            seed = atoi(argv[4]);
          }
          

          int *dataset = (int *) malloc(sizeof(int) * array_size);
          fill_random(dataset, array_size, seed);

          if (before_sort_action == SORT) {
            sort_quick_optimized(dataset, 0, array_size - 1);
          } else if (before_sort_action == SORT_REVERSE) {
            sort_quick_optimized(dataset, 0, array_size - 1);
            for (int i = 0; i < array_size / 2; i++) {
              swap(&dataset[i], &dataset[array_size - 1 - i]);
            }
          } else if (before_sort_action == LIMIT_VALUES_1000) {
            for (int i = 0; i < array_size; i++) {
              dataset[i] = dataset[i] % 1000;
            }
          } else if (before_sort_action == LIMIT_VALUES_10000) {
            for (int i = 0; i < array_size; i++) {
              dataset[i] = dataset[i] % 10000;
            }
          }
          int *data_to_sort = (int *) malloc(sizeof(int) * array_size);

          clock_t total = 0;
          int runs = 0;
          while ((total < 10000000 || runs < MIN_RUNS_PER_BENCH) && runs < MAX_RUNS_PER_BENCH) {
            printf("\r");
            printf("Benching %s with size %d, seed %d, and action %d at run %d  ", algorithm.name, array_size, seed, before_sort_action, runs);
            fflush(stdout);

            for (int i = 0; i < array_size; i++) {
              data_to_sort[i] = dataset[i];
            }

            uint64_t start = __rdtsc();
            algorithm.sorting_function(data_to_sort, 0, array_size - 1);
            uint64_t stop = __rdtsc();
            total += (stop - start);
            individual_times[runs] = (float)(stop - start) / CLOCKS_PER_SEC * 1000;


            // Verify integrity
            for (int i = 0; i < array_size - 1; i++) {
              if (data_to_sort[i] > data_to_sort[i + 1]) {
                printf("\nIntegrity violation!\n");
                for (int index = 0; index < array_size; index++) {
                  printf("%d ", data_to_sort[index]);
                }
                printf("\n");
                exit(1);
              }
            }

            runs++;
          }

          free(dataset);
          free(data_to_sort);

          fprintf(file, "%s,%d,%d,%d,%d", algorithm.name, array_size, seed, before_sort_action, runs);

          float mean = (float)(total)*1000 / CLOCKS_PER_SEC / runs;
          last_mean += mean;
          runs_of_size++;
          float sum = 0;
          for (int index = 0; index < runs; index++) {
            float diff = mean - individual_times[index];
            float square = powf(diff, 2);
            sum += square; 
          }
          float std_dev = sqrtf(sum / (float)runs);
          fprintf(file, ",%f", mean);
          fprintf(file, ",%f", mean / array_size);
          fprintf(file, ",%f", std_dev);
          for (int index = 0; index < runs; index++) {
            fprintf(file, ",%f", individual_times[index]);
          }
          fprintf(file, "\n");
        }
      }
    }
    if (runs_of_size != 0) {
      printf("  Average: %.3f\n", last_mean / runs_of_size);
    }
  }
}
