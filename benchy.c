
#include "blockquick.h"
#include "data-random.h"
#include "insertionssort.h"
#include "heapsort.h"
#include "heapsorto.h"
#include "median.h"
#include "mergeo.h"
#include "mergeu.h"
#include "minmax.h"
#include "quicko.h"
#include "quickodualpivot.h"
#include "quickomulti.h"
#include "quickomultiinplace.h"
#include "quickomultix4.h"
#include "quickomultix4inplace.h"
#include "quickosimd.h"
#include "quickostable.h"
#include "quickoswaparith.h"
#include "quickoswaparray.h"
#include "quickoswapasm.h"
#include "quickoswapcmov.h"
#include "quicku.h"
#include "simd.h"
#include "swap.h"
#include "timsort.h"
#include "const.h"

#include <math.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <unistd.h>
#include <x86intrin.h>

#define DATA_AMOUNT 2000000
#define MIN_RUNS_PER_BENCH 10
#define MAX_RUNS_PER_BENCH 10000

int original_data[DATA_AMOUNT];

void shuffle_data(int data_to_sort[], int size) {
  size_t i;
  for (i = 0; i < size; i++) {
    size_t j = (i + rand()) % size;
    int t = data_to_sort[j];
    data_to_sort[j] = data_to_sort[i];
    data_to_sort[i] = t;
    //data_to_sort[i] = original_data[i];
  }
}

float individual_times[MAX_RUNS_PER_BENCH];
float reference_value = 0;

void bench(char name[], void (*fun)(int *, int64_t, int64_t), int array_size,
           int data_to_sort[]) {

  if (array_size == -1) {
    printf("%s", name);
    return;
  }  

  // printf("Testing %s with array size %d: ", name, array_size);

  clock_t total = 0;
  int runs = 0;
  while ((total < 400000000 || runs < MIN_RUNS_PER_BENCH) &&
         runs < MAX_RUNS_PER_BENCH) {
    runs++;
    shuffle_data(data_to_sort, array_size);
    // struct timespec start, stop;
    uint64_t start = __rdtsc();
    fun(data_to_sort, 0, array_size - 1);
    uint64_t stop = __rdtsc();
    total += (stop - start);
    individual_times[runs - 1] = (float)(stop - start) / CLOCKS_PER_SEC * 1000;

    /*if (runs == 1 && array_size == 10) {
      printf("\n");
      for (int i = 0; i < array_size; i++) {
        printf("%d ", data_to_sort[i]);
      }
      printf("\n");
    }*/

    if (runs == 1) {
      for (int index = 0; index < array_size - 1; index++) {
        if (data_to_sort[index] > data_to_sort[index + 1]) {
          printf("\nArray ");
          for (int64_t pindex = 0; pindex <= array_size; pindex++) {
            printf("%d ", data_to_sort[pindex]);
          }
          // printf("\n");

          printf("Integrity check failed for %s at index %d\n", name,
                 index + 1);
          exit(1);
        }
      }
    }
  }

  float mean = (float)(total)*1000 / CLOCKS_PER_SEC / runs;
  float sum = 0;
  for (int index = 0; index < runs; index++) {
    float diff = mean - individual_times[index];
    float square = powf(diff, 2);
    sum += square;
  }
  float std_dev = sqrtf(sum / (float)runs);

  if (reference_value == 0) {
    reference_value = mean;
  }

  char *output = (char *)malloc(20 * sizeof(char));
  sprintf(output, "                   ");
  //sprintf(output, "%.2f±%.2f", mean, std_dev);
  if (mean < 1) {
    sprintf(output, "%.2f±%.2f %.0f%%", mean, std_dev, mean / reference_value * 100);
  } else if (mean < 10) {
    sprintf(output, "%.1f±%.1f %.0f%%", mean, std_dev, mean / reference_value * 100);
  } else {
    sprintf(output, "%.0f±%.0f %.0f%%", mean, std_dev, mean / reference_value * 100);
  }

  for (int index = 0; index < 20; index++) {
    if (output[index] == '\0') {
      output[index] = ' ';
    }
  }
  printf("%s", output);

  free(output);
}

/*void bench_min_max(int(fun)(int, int)) {

  clock_t total = 0;
  for (int i = 0; i < RUNS_PER_BENCH; i++) {
    clock_t start = clock();
    shuffle_data(10);
    int x = data_to_sort[4];
    int y = data_to_sort[7];
    int z = fun(x, y);
    clock_t stop = clock();
    data_to_sort[2] = z;
    total += stop - start;
  }

  float msec = (float)(total)*1000000 / CLOCKS_PER_SEC / RUNS_PER_BENCH;

  printf("Microseconds: %.3f\n", msec);
}*/

int main() {
  printf("Starting\n");
  int array_sizes[7] = {-1, /*10, 20, 30,*/ 10, 100, 1000, 10000, 100000, 1000000};

  int data_to_sort[DATA_AMOUNT];

  /*bench_min_max(min);
  bench_min_max(min_branchless);
  bench_min_max(max);
  bench_min_max(max_branchless);*/
  printf("Generating random data\n");
  random_data(data_to_sort, DATA_AMOUNT);

  for (int i = 0; i < sizeof array_sizes / sizeof array_sizes[0]; i++) {
    reference_value = 0;
    bench("QStd               ", sort_quick_standard, array_sizes[i],
          data_to_sort);
    bench("QOpt               ", sort_quick_optimized, array_sizes[i], data_to_sort);
    bench("QSIMD              ", sort_quick_simd, array_sizes[i], data_to_sort);
    bench("QArith             ", sort_quick_optimized_swap_arith, array_sizes[i],
          data_to_sort);
    bench("QCMov              ", sort_quick_optimized_swap_cmov, array_sizes[i],
          data_to_sort);
    bench("QArray             ", sort_quick_optimized_swap_array, array_sizes[i],
          data_to_sort);
    bench("QAsm               ", sort_quick_optimized_swap_asm, array_sizes[i],
          data_to_sort);
    bench("QStable            ", sort_quick_stable, array_sizes[i], data_to_sort);
    bench("QMultx8            ", sort_quick_multi, array_sizes[i], data_to_sort);
    bench("QMultx4            ", sort_quick_multix4, array_sizes[i], data_to_sort);
    //bench("QMultx8Inplace     ", sort_quick_multi_inplace, array_sizes[i],
    //      data_to_sort);
    //bench("QMultx4Inplace     ", sort_quick_multi_x4_inplace, array_sizes[i],
    //      data_to_sort);
    //bench("QDual              ", sort_quick_optimized_dual, array_sizes[i],
    //      data_to_sort);

    bench("QBlock             ", sort_quick_block, array_sizes[i], data_to_sort);

    bench("MSStd              ", sort_merge_standard, array_sizes[i],
          data_to_sort);
    bench("MSOpt              ", sort_merge_optimized, array_sizes[i],
          data_to_sort);
    bench("Heap               ", heapsort, array_sizes[i], data_to_sort);
    bench("HeapO              ", heapsorto, array_sizes[i], data_to_sort);
    //bench("Timsort            ", timsort, array_sizes[i], data_to_sort);
    if (array_sizes[i] <= 10000) {
      bench("Insertion          ", insertionSortStd, array_sizes[i] <= 10000 ? array_sizes[i] : 10000,
            data_to_sort);
    }
    printf("\n");
  }

  /*random_data(data_to_sort, DATA_AMOUNT);

  sort_quick_optimized(data_to_sort, 0, DATA_AMOUNT);

  clock_t total = 0;
  for (int i = 0; i < RUNS_PER_BENCH; i++) {
    shuffle_data(DATA_AMOUNT);
    clock_t start = clock();
    sort_quick_simd(data_to_sort, 0, DATA_AMOUNT);
    clock_t stop = clock();
    total += stop - start;
  }

  float msec = (float)(total)*1000000 / CLOCKS_PER_SEC / RUNS_PER_BENCH;

  printf("%f\t", msec);*/
}
