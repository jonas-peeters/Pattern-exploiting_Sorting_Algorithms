#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <stdint.h>

#include <emmintrin.h> //SSE2
#include <immintrin.h> //AVX, AVX2, AVX-512
#include <nmmintrin.h> //SSE4.2
#include <pmmintrin.h> //SSE3
#include <smmintrin.h> //SSE4.1
#include <xmmintrin.h> //for SSE

void swap(int *a, int *b);
void insertionSortOptimized(int array[], int n);
void sort_quick_optimized(int array[], int64_t low, int64_t high);
void sort_pair(int *i1, int *i2);
int median_of_three(int array[], int64_t low, int64_t high);
int x[2];


void partition_quick_multi_x4_inplace(int array[], int64_t low, int64_t high,
                                   int *t0, int *t1/*, int *t2, int *t3*/) {
  //sort_pair(&array[low], &array[low + 1]);
  //sort_pair(&array[low + 1], &array[low + 2]);
  //sort_pair(&array[low + 2], &array[low + 3]);
  //median_of_three(array, low, high);
  //swap(&array[high], &array[low + 1]);

  //sort_pair(&array[low], &array[low + 1]);
  //sort_pair(&array[low + 1], &array[low + 2]);

  sort_pair(&array[low], &array[low + 1]);
  int p1 = array[low];
  int p2 = array[low + 1];
  //int p3 = array[low + 2];
  //int p4 = array[low + 3];

  //__m128i pivots = _mm_loadu_si128((__m128i *)&array[low]);
  //__m128i zeros = _mm_set1_epi32(0);
//
  //int compArray[4];

  for (int64_t j = low + 2; j <= high; j++) {
    int x = array[j];
    //__m128i currentValue = _mm_set1_epi32(x);
    //_mm_storeu_si128((__m128i *) &compArray, 
    //                 _mm_sub_epi32(zeros, 
    //                               _mm_cmpgt_epi32(pivots,
    //                                               currentValue)));

    int a = array[*t0];
    int c = x < p1;//compArray[0];
    array[*t0] = c ? x : a;
    x = c ? a : x;
    *t0 += c;

    a = array[*t1];
    c = x < p2;//compArray[1];
    array[*t1] = c ? x : a;
    x = c ? a : x;
    *t1 += c;

    //a = array[*t2];
    //c = x < p3;//compArray[2];
    //array[*t2] = c ? x : a;
    //x = c ? a : x;
    //*t2 += c;
    //
    //a = array[*t3];
    //c = x < p4;//compArray[3];
    //array[*t3] = c ? x : a;
    //x = c ? a : x;
    //*t3 += c;

    array[j] = x;
  }
}

void sort_quick_multi_x4_inplace_h(int array[], int64_t low, int64_t high) {
  // printf("Sorting from %d to %d\n", low, high);
  if (low < high) {
    if (high - low > 1000) {
      //int pivots[4] = {low, low + 1, low + 2, low + 3};
      int t0 = low;
      int t1 = low + 1;
      //int t2 = low + 2;
      //int t3 = low + 3;
      partition_quick_multi_x4_inplace(array, low, high, &t0, &t1/*, &t2, &t3*/);
      //printf("Pivots %d, %d: ", low, high);
      //for (int64_t index = 0; index < 5; index++) {
      //  printf("%d ", pivots[index]);
      //}
      //printf("\n");

      sort_quick_multi_x4_inplace_h(array, low, t0 - 1);
      sort_quick_multi_x4_inplace_h(array, t0, t1 - 1);
      //sort_quick_multi_x4_inplace_h(array, t1, t2 - 1);
      //sort_quick_multi_x4_inplace_h(array, t2, t3 - 1);
      //sort_quick_multi_x4_inplace_h(array, pivots[3], high);
      sort_quick_multi_x4_inplace_h(array, t1, high);
    } else {
      sort_quick_optimized(array, low, high);
      // insertionSortOptimized(array + low, high - low + 1);
    }
  }
}

void sort_quick_multi_x4_inplace(int array[], int64_t low, int64_t high) {
  sort_quick_multi_x4_inplace_h(array, low, high + 1);
}
