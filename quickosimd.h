#include <emmintrin.h> //SSE2
#include <immintrin.h> //AVX, AVX2, AVX-512
#include <nmmintrin.h> //SSE4.2
#include <pmmintrin.h> //SSE3
#include <smmintrin.h> //SSE4.1
#include <xmmintrin.h> //for SSE

#include "const.h"

#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

void swap(int *a, int *b);
int median_of_three_auto_finish(int array[], int64_t low, int64_t high, int *done);

int x[2];

typedef int v4si __attribute__((vector_size(8)));

int64_t partition_quick_simd(int array[], int64_t low, int64_t high) {
  __m256i zeros = _mm256_set1_epi32(0);
  int done = 0;
  int pivot = median_of_three_auto_finish(array, low, high, &done);
  if (done) {
    return (low + high) / 2;
  }
  int64_t i = low;
  int64_t j = low;
  __m256i p = _mm256_set1_epi32(pivot);
  for (; j < high - 7;) {

    __m256i values = _mm256_loadu_si256((__m256i *)&array[j]);
    __m256i cs = _mm256_sub_epi32(zeros, _mm256_cmpgt_epi32(p, values));

    int carray[8];
    _mm256_storeu_si256((__m256i_u *)&carray[0], cs);

    for (int64_t k = 0; k < 8; k++) {
      int c = carray[k];
      int x[2];
      // int y = array[i];
      // int z = array[j];
      // array[i] = c ? z : y;
      // array[j] = c ? y : z;
      // int d = array[i] * c + array[j] * (1 - c);
      // int f = array[i] * (1 - c) + array[j] * c;
      // array[j] = d;
      // array[i] = f;
      x[0] = array[i];
      x[1] = array[j];
      array[i] = x[c];
      array[j] = x[1 - c];
      i += c;
      j++;
    }
  }
  for (; j < high; j++) {
    int c = pivot > array[j];
    int x[2];
    // int y = array[i];
    // int z = array[j];
    // array[i] = c ? z : y; // x[c];
    // array[j] = c ? y : z; // x[1 - c];
    // int d = array[i] * c + array[j] * (1 - c);
    // int f = array[i] * (1 - c) + array[j] * c;
    // array[j] = d;
    // array[i] = f;
    x[0] = array[i];
    x[1] = array[j];
    array[i] = x[c];
    array[j] = x[1 - c];
    i += c;
  }
  swap(&array[i], &array[high]);
  return (i);
}

void sort_quick_simd(int array[], int64_t low, int64_t high) {
  // printf("Sorting from %d to %d\n", low, high);
  if (low < high) {
    int64_t pi = partition_quick_simd(array, low, high);
    // printf("New pivot is %d\n", pi);
    sort_quick_simd(array, low, pi - 1);
    sort_quick_simd(array, pi + 1, high);
  }
}
