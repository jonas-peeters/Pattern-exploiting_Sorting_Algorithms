#include <emmintrin.h> //SSE2
#include <immintrin.h> //AVX, AVX2, AVX-512
#include <nmmintrin.h> //SSE4.2
#include <pmmintrin.h> //SSE3
#include <smmintrin.h> //SSE4.1
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <xmmintrin.h> //for SSE

void swap(int *a, int *b);
int median_of_three(int array[], int low, int high);

int x[2];

typedef int v4si __attribute__((vector_size(8)));

int partition_quick_simd(int array[], int low, int high) {
  __m128i zeros = _mm_set1_epi32(0);
  int pivot =
      high - low >= 2 ? median_of_three(array, low, high) : array[high]; //
  int i = low;
  int j = low;
  __m128i p = _mm_set1_epi32(pivot);
  for (; j < (high - low) / 4 * 4;) {

    __m128i values = _mm_loadu_si128((__m128i *)&array[j]);
    __m128i cs = _mm_sub_epi32(zeros, _mm_cmpgt_epi32(p, values));

    int carray[4];
    _mm_storeu_si128((__m128i_u *)&carray[0], cs);

    __m128i offsets = cs;
    offsets = _mm_add_epi32(offsets, _mm_slli_si128(offsets, 4));
    offsets = _mm_add_epi32(offsets, _mm_slli_si128(offsets, 8));

    int offsetarray[4];
    _mm_storeu_si128((__m128i_u *)&offsetarray[0], offsets);
    int totalOffset = _mm_extract_epi32(offsets, 3);

    printf("Cs:      ");
    for (int r = 0; r < 4; r++) {
      printf("%d ", carray[r]);
    }
    printf("\n");

    printf("Offsets: ");
    for (int r = 0; r < 4; r++) {
      printf("%d ", offsetarray[r]);
    }
    printf("\n");

    for (int k = 0; k < 4; k++) {
      int c = carray[k];
      // int y = array[i];
      // int z = array[ind];
      // array[i] = c ? z : y;
      // array[ind] = c ? y : z;
      // x[0] = array[i];
      // x[1] = array[ind];
      // array[i] = x[c];
      // array[ind] = x[1 - c];
      int d = array[i] * c + array[j] * (1 - c);
      int f = array[i] * (1 - c) + array[j] * c;
      array[i] = f;
      array[j] = d;
      i += c;
      j++;
    }
  }
  for (; j < high; j++) {
    int c = pivot > array[j];
    // int y = array[i];
    // int z = array[j];
    // array[i] = c ? z : y; // x[c];
    // array[j] = c ? y : z; // x[1 - c];
    int d = array[i] * c + array[j] * (1 - c);
    int f = array[i] * (1 - c) + array[j] * c;
    array[i] = f;
    array[j] = d;
    i += c;
  }
  swap(&array[i], &array[high]);
  return (i);
}

void sort_quick_simd(int array[], int low, int high) {
  // printf("Sorting from %d to %d\n", low, high);
  if (low < high) {
    int pi = partition_quick_simd(array, low, high);
    // printf("New pivot is %d\n", pi);
    sort_quick_simd(array, low, pi - 1);
    sort_quick_simd(array, pi + 1, high);
  }
}
