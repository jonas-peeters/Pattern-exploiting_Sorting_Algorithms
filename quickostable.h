#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#include <emmintrin.h> //SSE2
#include <immintrin.h> //AVX, AVX2, AVX-512
#include <nmmintrin.h> //SSE4.2
#include <pmmintrin.h> //SSE3
#include <smmintrin.h> //SSE4.1
#include <xmmintrin.h> //for SSE

void swap(int *a, int *b);
void insertionSortOptimized(int array[], int n);
void sort_quick_multix4_h(int array[], int64_t low, int64_t high, int tmp[]);
int median_of_three_stable(int array[], int64_t low, int64_t high);
int x[2];

void partition_quick_stable(int array[], int smaller_values[], int equal_values[], int reverse, int64_t low, int64_t high, int64_t low_target, int64_t *smaller, int64_t *larger, int64_t *equal) {
  int *from = reverse ? smaller_values : array;

  int pivot = median_of_three_stable(from, low, high);
  
  int64_t i = low_target;
  int64_t k = low;
  int64_t h = low;

  //asm volatile("    movq     %[k], %%r11\n"
  //             "1:\n"
  //             "\n" // Loop start
  //             "    movl     (%[from],%%r11,4), %%r8d\n"
  //             //"    movl     $1, %%r12d\n"
  //
  //             "    xorq     %%r10, %%r10\n"
  //             "    movl     (%[array],%[i],4), %%r9d\n"
  //             "    cmp      %[pivot], %%r8d\n"
  //             "    setl     %%r10b\n"
  //             //"    cmovll   %%r12d, %%r10d\n"
  //             "    cmovll   %%r8d, %%r9d\n"
  //             "    movl     %%r9d, (%[array],%[i],4)\n"
  //             "    addq     %%r10, %[i]\n" 
  //
  //             "    xorq     %%r10, %%r10\n"
  //             "    movl     (%[tmp],%[k],4), %%r9d\n"
  //             "    cmp      %[pivot], %%r8d\n"
  //             "    setg     %%r10b\n"
  //             //"    cmovgl   %%r12d, %%r10d\n"
  //             "    cmovgl   %%r8d, %%r9d\n"
  //             "    movl     %%r9d, (%[tmp],%[k],4)\n"
  //             "    addq     %%r10, %[k]\n"
  //
  //             "    xorq     %%r10, %%r10\n"
  //             "    movl     (%[tmp],%[h],4), %%r9d\n"
  //             "    cmp      %[pivot], %%r8d\n"
  //             "    sete     %%r10b\n"
  //             //"    cmovel   %%r12d, %%r10d\n"
  //             "    cmovel   %%r8d, %%r9d\n"
  //             "    movl     %%r9d, (%[tmp],%[h],4)\n"
  //             "    subq     %%r10, %[h]\n"
  //
  //             "\n" // Loop end
  //             "    incq     %%r11\n"
  //             "    cmp      %[high], %%r11\n"
  //             "    jle      1b\n"
  //             : [i] "+r"(i), [k] "+r"(k), [h] "+r"(h)
  //             : [array] "r"(array), [tmp] "r"(tmp), [from] "r"(from), [pivot] "r"(pivot), [high] "r"(high)
  //             : "cc", "r8", "r9", "r10", "r11");

  for (int64_t j = low; j <= high; j++) {
    int x = from[j];
    array[i] = x;
    i += pivot > x;
    smaller_values[k] = x;
    k += pivot < x;
    equal_values[h] = x;
    h += pivot == x;
    //if (pivot > x) {
    //  array[i] = x;
    //  i++;
    //} else if (pivot < x) {
    //  smaller_values[k] = x;
    //  k++;
    //} else {
    //  equal_values[h] = x;
    //  h++;
    //}
  }

  *smaller = i - 1;
  *larger = k - 1;
  for (int j = low; j < h; j++) {
    array[i++] = equal_values[j];
  }
  *equal = i - 1;
}

void sort_quick_stable_h(int array[], int smaller_values[], int equal_values[], int64_t low, int64_t high);

void sort_quick_stable_reverse_h(int array[], int smaller_values[], int equal_values[], int64_t low, int64_t high, int64_t low_target) {
  if (high - low > 2) {
    int64_t smaller, larger, equal;
    partition_quick_stable(array, smaller_values, equal_values, true, low, high, low_target, &smaller, &larger, &equal);
    sort_quick_stable_reverse_h(array, smaller_values, equal_values, low, larger, equal + 1);
    sort_quick_stable_h(array, smaller_values, equal_values, low_target, smaller);
    
  } else if (low < high) {
    median_of_three_stable(smaller_values, low, high);
    for (int i = 0; i <= high - low; i++) {
      array[low_target + i] = smaller_values[low + i];
    }
  } else if (low == high) {
    array[low_target] = smaller_values[low];
  }
}

void sort_quick_stable_h(int array[], int smaller_values[], int equal_values[], int64_t low, int64_t high) {
  if (high - low > 2) {
    int64_t smaller, larger, equal;
    partition_quick_stable(array, smaller_values, equal_values, false, low, high, low, &smaller, &larger, &equal);
    sort_quick_stable_reverse_h(array, smaller_values, equal_values, low, larger, equal + 1);
    sort_quick_stable_h(array, smaller_values, equal_values, low, smaller);

  } else if (low < high) {
    median_of_three_stable(array, low, high);
  }
}

void sort_quick_stable(int array[], int64_t low, int64_t high) {
  int *smaller_values = (int *) malloc(sizeof(int32_t) * (high - low + 1) * 2);
  int *equal_values = &smaller_values[(high - low + 1)];
  sort_quick_stable_h(array, smaller_values, equal_values, low, high);
  free(smaller_values);
}
