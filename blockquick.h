// Based on https://arxiv.org/pdf/1604.06697.pdf

#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

const int blocksize = 128;

void swap_quick_block(int *a, int *b) {
  int t = *a;
  *a = *b;
  *b = t;
}
int median_of_three(int array[], int low, int high);
int x[2];

int partition_quick_block(int array[], int low, int high) {
  
  int pivot = high - low > 2 ? median_of_three(array, low, high) : array[high];
  int pivot_position = high;
  high--;


  int offsetsL[blocksize], offsetsR[blocksize];
  int startL = 0, startR = 0, numL = 0, numR = 0;

  while (high - low + 1 > 2 * blocksize) {
    if (numL == 0) {
      startL = 0;
      for (int i = 0; i < blocksize; i++) {
        offsetsL[numL] = i;
        numL += pivot <= array[low + i];
      }
    }
    if (numR == 0) {
      startR = 0;
      for (int i = 0; i < blocksize; i++) {
        offsetsR[numR] = i;
        numR += pivot >= array[high - i];
      }
    }
    int num = min(numL, numR);
    for (int j = 0; j < num; j++) {
      swap_quick_block(&array[low + offsetsL[startL + j]], &array[high - offsetsR[startR + j]]);
    }
    numL -= num;
    numR -= num;
    startL += num;
    startR += num;
    if (numL == 0) {
      low += blocksize;
    }
    if (numR == 0) {
      high -= blocksize;
    }
  }

  int shiftR = 0, shiftL = 0;

  if (numR == 0 && numL == 0) {
    shiftL = (high - low + 1) / 2;
    shiftR = high - low + 1 - shiftL;
    startL = 0;
    startR = 0;
    for (int j = 0; j < shiftL; j++) {
      offsetsL[numL] = j;
      numL += pivot <= array[low + j];
      offsetsR[numR] = j;
      numR += pivot >= array[high - j];
    }
    if (shiftL < shiftR) {
      offsetsR[numR] = shiftR - 1;
      numR += pivot >= array[high - shiftR + 1];
    }
  } else if (numR != 0) {
    shiftL = high - low - blocksize + 1;
    shiftR = blocksize;
    startL = 0;
    for (int j = 0; j < shiftL; j++) {
      offsetsL[numL] = j;
      numL += pivot <= array[low + j];
    }
  } else {
    shiftR = high - low - blocksize + 1;
    shiftL = blocksize;
    startR = 0;
    for (int j = 0; j < shiftR; j++) {
      offsetsR[numR] = j;
      numR += pivot >= array[high - j];
    }
  }

  int num = min(numL, numR);

  for (int j = 0; j < num; j++) {
    swap_quick_block(&array[low + offsetsL[startL + j]], &array[high - offsetsR[startR + j]]);
  }

  numL -= num;
  numR -= num;
  startL += num;
  startR += num;
  if (numL == 0) {
    low += shiftL;
  }
  if (numR == 0) {
    high -= shiftR;
  }

  if (numL != 0) {
    int lower = startL + numL - 1;
    int upper = high - low;
    while (lower >= startL && offsetsL[lower] == upper) {
      upper--;
      lower--;
    }
    while (lower >= startL) {
      swap_quick_block(&array[low + upper--], &array[low + offsetsL[lower--]]);
    }
    swap_quick_block(&array[pivot_position], &array[low + upper + 1]);
    return low + upper + 1;
  } else if (numR != 0) {
    int lower = startR + numR - 1;
    int upper = high - low;
    while (lower >= startR && offsetsR[lower] == upper) {
      upper--;
      lower--;
    }
    while (lower >= startR) {
      swap_quick_block(&array[high - upper--], &array[high - offsetsR[lower--]]);
    }
    swap_quick_block(&array[pivot_position], &array[high - upper]);
    return high - upper;
  } else {
    swap_quick_block(&array[pivot_position], &array[low]);
    return low;
  }
}

void sort_quick_block(int array[], int low, int high) {
  if (low < high) {
    int pi = partition_quick_block(array, low, high);
    sort_quick_block(array, low, pi - 1);
    sort_quick_block(array, pi + 1, high);
  }
}
