#include "blockquick.h"
#include "data-random.h"
#include "swap.h"
#include "const.h"
#include "minmax.h"
#include "median.h"
#include "insertionssort.h"
#include "quickoswapcmov.h"
#include "quickoswaparray.h"
#include "quickoswapasm.h"
#include "quickuhoare.h"
#include "quickulomuto.h"
#include "pdqsort.h++"
#include "quickoint.h"
#include "quicko.h"
#include "quickotuned.h"
#include "quickocomp.h"
#include "tim/timsort.h"


#include <math.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
#include <iostream>
#include <time.h>
#include <unistd.h>
#include <x86intrin.h>


#include "papi.h"

#include <math.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <x86intrin.h>

#include "mergestdu.h++"
#include "mergestdo.h++"
#include "mergestdcmov.h++"
#include "mergestdarray.h++"
#include "mergestdarith.h++"

#include "BlockQuicksort/blocked_double_pivot_check_mosqrt.h++"


#define SEEDS_AMOUNT 6 // First seed is thrown away for warmup
#define MIN_RUNS_PER_BENCH 3
#define MAX_RUNS_PER_BENCH 100

enum before_sort_actions {
  NOTHING,
  PRESORTED,
  SORT_REVERSE,
  END_RANDOM,
  LIMIT_VALUES_1000,
  LIMIT_VALUES_10000
};

struct Algorithm {
  char name[50];
  void (*sorting_function) (int *, int, int);
};

struct BeforeSortAction {
  char name[50];
  int action;
};

int compare_ints (int da, int db){
  return da < db;
}

template<typename _Iterator1, typename _Iterator2>
bool iter_less_iter(_Iterator1 __it1, _Iterator2 __it2) { 
  return *__it1 < *__it2;
}

void std_sort(int* array, int low, int high) {
  std::sort(&array[low], &array[high + 1], std::less<int>());
}

void std_stable_sort(int* array, int low, int high) {
  standardlib::stable_sort(&array[low], &array[high + 1], std::less<int>());
}

void std_stable_sort_opt(int* array, int low, int high) {
  pems::stable_sort(&array[low], &array[high + 1], std::less<int>());
}

void std_stable_sort_cmov(int* array, int low, int high) {
  standardlibcmov::stable_sort(&array[low], &array[high + 1]);
}
void std_stable_sort_array(int* array, int low, int high) {
  standardlibarray::stable_sort(&array[low], &array[high + 1]);
}
void std_stable_sort_arith(int* array, int low, int high) {
  standardlibarith::stable_sort(&array[low], &array[high + 1]);
}

void tim_sort(int* array, int low, int high) {
  tim::timsort(&array[low], &array[high + 1], std::less<int>());
}

void pdqsort(int* array, int low, int high) {
  pdqsort_branchless(&array[low], &array[high + 1], std::less<int>());
}

void block(int* array, int low, int high) {
  blocked_double_pivot_check_mosqrt::sort(&array[low], &array[high + 1], std::less<int>());
}


void peqsort(int* array, int low, int high) {
  peqs::sort(&array[low], &array[high], std::less<int>());
}

void peqsort_int(int* array, int low, int high) {
  peqsint::sort(&array[low], &array[high]);
}

void handle_error(int retval) {
  if (retval != PAPI_OK) {
    printf("PAPI error %d: %s\n", retval, PAPI_strerror(retval));
    exit(1);
  }
}

// Args
// 1. Algorithm name
// 2. Before sort action
// 3. Array Size
// 4. Seed
int main(int argc, char *argv[]) {
  printf("Starting\n");
  
  int seeds[SEEDS_AMOUNT];
  for (int i = 0; i < SEEDS_AMOUNT; i++) {
    seeds[i] = i;
  }

  int array_sizes[] = {5, 7, 10, 15, 20, 25, 30, 40, 50, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000};
  struct Algorithm algorithms[] = {
    {"Merge libstdc++        ", std_stable_sort},
    {"Merge libstdc++ CMOV   ", std_stable_sort_cmov},
    {"Merge libstdc++ Array  ", std_stable_sort_array},
    {"Merge libstdc++ Arith  ", std_stable_sort_arith},
    {"PEMS                   ", std_stable_sort_opt},
    {"Timsort                ", tim_sort},
    {"Quicksort libc++       ", std_sort},
    {"PEQS                   ", peqsort},
    //{"PEQS Integer           ", peqsort_int},
    {"BlockQuicksort         ", block},
    {"pdqsort                ", pdqsort},
    {"Quicksort Std Lomuto   ", sort_quick_lomuto},
    {"Quicksort Std Hoare    ", sort_quick_hoare},
    {"Quicksort Swap CMOV    ", sort_quick_optimized_swap_cmov},
    {"Quicksort Swap Array   ", sort_quick_optimized_swap_array},
    {"Quicksort Swap ASM     ", sort_quick_optimized_swap_asm},
    {"Quicksort tuned        ", sort_quick_tuned}
  };

  struct BeforeSortAction before_sort_actions[] = {
    {"NOTHING", NOTHING},
    {"PRESORTED", PRESORTED},
    {"SORT_REVERSE", SORT_REVERSE},
    {"END_RANDOM", END_RANDOM},
    {"LIMIT_VALUES_1000", LIMIT_VALUES_1000},
    //{"LIMIT_VALUES_10000", LIMIT_VALUES_10000}
  };

  float randomnes[] = {0.0, 0.00001, 0.0001, 0.001, 0.005, 0.01, 0.05, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9};

  int cpu_counters[] = {
    PAPI_BR_CN, 
    PAPI_BR_MSP, 
    PAPI_TOT_CYC, 
    PAPI_REF_CYC,
    PAPI_L1_DCM
  };

  int CPU_COUNTER_COUNT = sizeof(cpu_counters) / sizeof(*cpu_counters);
  int event_set = PAPI_NULL;
  int version = PAPI_library_init(PAPI_VER_CURRENT);
  handle_error(PAPI_create_eventset(&event_set));
  for (int i = 0; i < CPU_COUNTER_COUNT; i++) {
    handle_error(PAPI_add_event(event_set, cpu_counters[i]));
  }
  handle_error(PAPI_start(event_set));


  FILE *file;
  #if defined(__clang__)
  file = fopen("output-clang-c++.csv", "w");
  #else
  file = fopen("output-gcc-c++.csv", "w");
  #endif

  fprintf(file, "Algorithm,Array size,Pre bench action,Randomnes,Average Cycles,Cycles per Element,Std Dev");

  for (int i = 0; i < CPU_COUNTER_COUNT; i++) {
    PAPI_event_info_t info;
    handle_error(PAPI_get_event_info(cpu_counters[i], &info));
    fprintf(file, ",%s", info.long_descr);
    fprintf(file, ",%s per element", info.long_descr);
  }
  for (int i = 1; i < SEEDS_AMOUNT; i++) {
    fprintf(file, ",Seed %d", i);
    fprintf(file, ",Runs for seed %d", i);
  }
  fprintf(file, "\n");


  for (int algo_index = 0; algo_index < sizeof(algorithms) / sizeof(algorithms[0]); algo_index++) {
    float last_mean = 0;
    float runs_of_size = 0;

    struct Algorithm algorithm = algorithms[algo_index];
    if (argc > 1) {
      if (!strstr(algorithm.name, argv[1]) && !strstr("*", argv[1])) {
        continue;
      }
    }

    for (int action_index = 0; action_index < sizeof(before_sort_actions) / sizeof(before_sort_actions[0]); action_index++) {          
      struct BeforeSortAction before_sort_action_struct = before_sort_actions[action_index];
      if (argc > 2) {
        if (!strstr("*", argv[2])) {
          if (action_index != 0) {
            continue;
          }
          before_sort_action_struct = before_sort_actions[atoi(argv[2])];
        }
      }
      int before_sort_action = before_sort_action_struct.action;

      for (int randomnes_index = 0; randomnes_index < sizeof(randomnes) / sizeof(randomnes[0]); randomnes_index++) {
        if (before_sort_action != PRESORTED && before_sort_action != END_RANDOM && randomnes_index != 0) {
          continue;
        }
        float randomnes_value = randomnes[randomnes_index];

        for (int size_index = 0; size_index < sizeof(array_sizes) / sizeof(array_sizes[0]); size_index++) {
          int array_size = array_sizes[size_index];
          if (argc > 3) {
            if (size_index != 0) {
              continue;
            }
            array_size = atoi(argv[3]);
          }

          // We only care about some size-before sort action-combinations for the graphs
          if (((before_sort_action > 2 && array_size > 10000000) ||
            (before_sort_action == 1 && randomnes_index != 0 && array_size > 10000000) ||
            (before_sort_action == 1 && array_size < 10000000) ||
            (before_sort_action == 3 && array_size < 10000000) ||
            (before_sort_action == 4 && array_size < 1000)) && argc <= 3
          ) {
            continue;
          }

          runs_of_size = 0;
          last_mean = 0;

          double *seed_times = (double *) calloc(SEEDS_AMOUNT, sizeof(double));
          int *seed_runs = (int *) calloc(SEEDS_AMOUNT, sizeof(int));
          double *event_values_of_row = (double *) calloc(sizeof(cpu_counters) / sizeof(*cpu_counters), sizeof(double));

          int seeds_performed = 0;

          for (int seed_index = 0; seed_index < SEEDS_AMOUNT; seed_index++) {
            int seed = seeds[seed_index];
            if (argc > 4) {
              if (seed_index > 1) {
                continue;
              }
              seed = atoi(argv[4]);
            }
            seeds_performed++;
          

            int *dataset = (int *) malloc(sizeof(int) * array_size);
            fill_random(dataset, array_size, seed);

            if (before_sort_action == PRESORTED) {
              std_stable_sort_opt(dataset, 0, array_size - 1);
              randomise(dataset, 0, array_size - 1, randomnes_value, seed);
            } else if (before_sort_action == END_RANDOM) {
              std_sort(dataset, 0, (array_size - 1) * (1 - randomnes_value));
            } else if (before_sort_action == SORT_REVERSE) {
              std_sort(dataset, 0, array_size - 1);
              for (int i = 0; i < array_size / 2; i++) {
                swap(&dataset[i], &dataset[array_size - 1 - i]);
              }
            } else if (before_sort_action == LIMIT_VALUES_1000) {
              for (int i = 0; i < array_size; i++) {
                dataset[i] = dataset[i] % 1000;
              }
            } else if (before_sort_action == LIMIT_VALUES_10000) {
              for (int i = 0; i < array_size; i++) {
                dataset[i] = dataset[i] % 10000;
              }
            }
            int *data_to_sort = (int *) malloc(sizeof(int) * array_size);

            long long int seed_total = 0;
            int runs = 0;
            long long int *event_values_of_seed = (long long int *) malloc(sizeof(long long int) * sizeof(cpu_counters) / sizeof(*cpu_counters));
            for (int i = 0; i < CPU_COUNTER_COUNT; i++) {
              event_values_of_seed[i] = 0;
            }

            while ((seed_total < 10000000 || runs < MIN_RUNS_PER_BENCH) && runs < MAX_RUNS_PER_BENCH) {
              printf("\r");
              printf("Benching %s with size %d, action %s, randomnes %f, seed %d and run %d", algorithm.name, array_size, before_sort_action_struct.name, randomnes_value, seed, runs);
              fflush(stdout);

              for (int i = 0; i < array_size; i++) {
                data_to_sort[i] = dataset[i];
              }
            
              handle_error(PAPI_reset(event_set));
              algorithm.sorting_function(data_to_sort, 0, array_size - 1);
              handle_error(PAPI_accum(event_set, event_values_of_seed));
              seed_total = event_values_of_seed[2];

              // Verify integrity
              for (int i = 0; i < array_size - 1; i++) {
                if (data_to_sort[i] > data_to_sort[i + 1]) {
                  printf("\nIntegrity violation!\n");
                  for (int index = 0; index < array_size; index++) {
                    printf("%d ", data_to_sort[index]);
                  }
                  printf("\n");
                  exit(1);
                }
              }
              runs++;
            }

            free(dataset);
            free(data_to_sort);

            seed_runs[seed_index] = runs;
            seed_times[seed_index] = (double)(seed_total) / runs;
            for (int i = 0; i < CPU_COUNTER_COUNT; i++) {
              event_values_of_row[i] = ((double) event_values_of_seed[i]) / (double) runs;
            }
            free(event_values_of_seed);


            
          }
          double seeds_total = 0;
          for (int index = 1; index < seeds_performed; index++) {
            seeds_total += seed_times[index];
          }

          fprintf(file, "%s,%d,%s,%f", algorithm.name, array_size, before_sort_action_struct.name, before_sort_action == PRESORTED || before_sort_action == END_RANDOM ? randomnes_value : -1);
          
          float mean = seeds_total / (seeds_performed - 1);

          last_mean += mean;
          runs_of_size++;
          float sum = 0;
          for (int index = 1; index < seeds_performed; index++) {
            float diff = mean - seed_times[index];
            float square = powf(diff, 2);
            sum += square; 
          }
          float std_dev = sqrtf(sum / (float)(seeds_performed - 1));
          fprintf(file, ",%f", mean);
          fprintf(file, ",%f", mean / array_size);
          fprintf(file, ",%f", std_dev);
          for (int index = 0; index < CPU_COUNTER_COUNT; index++) {
            fprintf(file, ",%f", event_values_of_row[index] / (seeds_performed - 1));
            fprintf(file, ",%f", event_values_of_row[index] / (seeds_performed - 1) / array_size);
          }
          for (int index = 1; index < seeds_performed; index++) {
            fprintf(file, ",%f", seed_times[index]);
            fprintf(file, ",%d", seed_runs[index]);
          }
          fprintf(file, "\n");
          free(seed_times);
          free(seed_runs);
          free(event_values_of_row);
          fflush(file);
        }

        if (runs_of_size != 0) {
          printf("  Average: %.3f\n", last_mean / runs_of_size);
        }
      }
    }
  }
}
