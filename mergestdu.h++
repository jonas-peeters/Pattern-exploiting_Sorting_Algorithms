// Algorithm implementation -*- C++ -*-

// Copyright (C) 2001-2022 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */

/** @file bits/stl_algo.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{algorithm}
 */

// See concept_check.h for the __glibcxx_*_requires macros.

namespace standardlib {

/// This is a helper function for the sort routine.
template <typename _RandomAccessIterator, typename _Compare>
void __unguarded_linear_insert(_RandomAccessIterator __last,
    _Compare __comp)
{
    typename std::iterator_traits<_RandomAccessIterator>::value_type
        __val
        = _GLIBCXX_MOVE(*__last);
    _RandomAccessIterator __next = __last;
    --__next;
    while (__comp(__val, __next)) {
        *__last = _GLIBCXX_MOVE(*__next);
        __last = __next;
        --__next;
    }
    *__last = _GLIBCXX_MOVE(__val);
}

/// This is a helper function for the sort routine.
template <typename _RandomAccessIterator, typename _Compare>
void __insertion_sort(_RandomAccessIterator __first,
    _RandomAccessIterator __last, _Compare __comp)
{
    if (__first == __last)
        return;

    for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i) {
        if (__comp(__i, __first)) {
            typename std::iterator_traits<_RandomAccessIterator>::value_type
                __val
                = _GLIBCXX_MOVE(*__i);
            _GLIBCXX_MOVE_BACKWARD3(__first, __i, __i + 1);
            *__first = _GLIBCXX_MOVE(__val);
        } else
            standardlib::__unguarded_linear_insert(__i,
                __gnu_cxx::__ops::__val_comp_iter(__comp));
    }
}

/// This is a helper function for the sort routine.
template <typename _RandomAccessIterator, typename _Compare>
inline void
__unguarded_insertion_sort(_RandomAccessIterator __first,
    _RandomAccessIterator __last, _Compare __comp)
{
    for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
        standardlib::__unguarded_linear_insert(__i,
            __gnu_cxx::__ops::__val_comp_iter(__comp));
}

/**
   *  @doctodo
   *  This controls some aspect of the sort routines.
  */
enum { _S_threshold = 16 };

/// This is a helper function for the sort routine.
template <typename _RandomAccessIterator, typename _Compare>
void __final_insertion_sort(_RandomAccessIterator __first,
    _RandomAccessIterator __last, _Compare __comp)
{
    if (__last - __first > int(_S_threshold)) {
        standardlib::__insertion_sort(__first, __first + int(_S_threshold), __comp);
        standardlib::__unguarded_insertion_sort(__first + int(_S_threshold), __last,
            __comp);
    } else
        standardlib::__insertion_sort(__first, __last, __comp);
}

// merge

/// This is a helper function for the __merge_adaptive routines.
template <typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
void __move_merge_adaptive(_InputIterator1 __first1, _InputIterator1 __last1,
    _InputIterator2 __first2, _InputIterator2 __last2,
    _OutputIterator __result, _Compare __comp)
{
    while (__first1 != __last1 && __first2 != __last2) {
        if (__comp(__first2, __first1)) {
            *__result = _GLIBCXX_MOVE(*__first2);
            ++__first2;
        } else {
            *__result = _GLIBCXX_MOVE(*__first1);
            ++__first1;
        }
        ++__result;
    }
    if (__first1 != __last1)
        _GLIBCXX_MOVE3(__first1, __last1, __result);
}

/// This is a helper function for the __merge_adaptive routines.
template <typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BidirectionalIterator3, typename _Compare>
void __move_merge_adaptive_backward(_BidirectionalIterator1 __first1,
    _BidirectionalIterator1 __last1,
    _BidirectionalIterator2 __first2,
    _BidirectionalIterator2 __last2,
    _BidirectionalIterator3 __result,
    _Compare __comp)
{
    if (__first1 == __last1) {
        _GLIBCXX_MOVE_BACKWARD3(__first2, __last2, __result);
        return;
    } else if (__first2 == __last2)
        return;

    --__last1;
    --__last2;
    while (true) {
        if (__comp(__last2, __last1)) {
            *--__result = _GLIBCXX_MOVE(*__last1);
            if (__first1 == __last1) {
                _GLIBCXX_MOVE_BACKWARD3(__first2, ++__last2, __result);
                return;
            }
            --__last1;
        } else {
            *--__result = _GLIBCXX_MOVE(*__last2);
            if (__first2 == __last2)
                return;
            --__last2;
        }
    }
}

/// This is a helper function for the merge routines.
template <typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _Distance>
_BidirectionalIterator1
__rotate_adaptive(_BidirectionalIterator1 __first,
    _BidirectionalIterator1 __middle,
    _BidirectionalIterator1 __last,
    _Distance __len1, _Distance __len2,
    _BidirectionalIterator2 __buffer,
    _Distance __buffer_size)
{
    _BidirectionalIterator2 __buffer_end;
    if (__len1 > __len2 && __len2 <= __buffer_size) {
        if (__len2) {
            __buffer_end = _GLIBCXX_MOVE3(__middle, __last, __buffer);
            _GLIBCXX_MOVE_BACKWARD3(__first, __middle, __last);
            return _GLIBCXX_MOVE3(__buffer, __buffer_end, __first);
        } else
            return __first;
    } else if (__len1 <= __buffer_size) {
        if (__len1) {
            __buffer_end = _GLIBCXX_MOVE3(__first, __middle, __buffer);
            _GLIBCXX_MOVE3(__middle, __last, __first);
            return _GLIBCXX_MOVE_BACKWARD3(__buffer, __buffer_end, __last);
        } else
            return __last;
    } else
        return std::rotate(__first, __middle, __last);
}

/// This is a helper function for the merge routines.
template <typename _BidirectionalIterator, typename _Distance,
    typename _Pointer, typename _Compare>
void __merge_adaptive(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last,
    _Distance __len1, _Distance __len2,
    _Pointer __buffer, _Distance __buffer_size,
    _Compare __comp)
{
    if (__len1 <= __len2 && __len1 <= __buffer_size) {
        _Pointer __buffer_end = _GLIBCXX_MOVE3(__first, __middle, __buffer);
        standardlib::__move_merge_adaptive(__buffer, __buffer_end, __middle, __last,
            __first, __comp);
    } else if (__len2 <= __buffer_size) {
        _Pointer __buffer_end = _GLIBCXX_MOVE3(__middle, __last, __buffer);
        standardlib::__move_merge_adaptive_backward(__first, __middle, __buffer,
            __buffer_end, __last, __comp);
    } else {
        _BidirectionalIterator __first_cut = __first;
        _BidirectionalIterator __second_cut = __middle;
        _Distance __len11 = 0;
        _Distance __len22 = 0;
        if (__len1 > __len2) {
            __len11 = __len1 / 2;
            std::advance(__first_cut, __len11);
            __second_cut
                = std::__lower_bound(__middle, __last, *__first_cut,
                    __gnu_cxx::__ops::__iter_comp_val(__comp));
            __len22 = std::distance(__middle, __second_cut);
        } else {
            __len22 = __len2 / 2;
            std::advance(__second_cut, __len22);
            __first_cut
                = std::__upper_bound(__first, __middle, *__second_cut,
                    __gnu_cxx::__ops::__val_comp_iter(__comp));
            __len11 = std::distance(__first, __first_cut);
        }

        _BidirectionalIterator __new_middle
            = std::__rotate_adaptive(__first_cut, __middle, __second_cut,
                __len1 - __len11, __len22, __buffer,
                __buffer_size);
        standardlib::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
            __len22, __buffer, __buffer_size, __comp);
        standardlib::__merge_adaptive(__new_middle, __second_cut, __last,
            __len1 - __len11,
            __len2 - __len22, __buffer,
            __buffer_size, __comp);
    }
}

/// This is a helper function for the merge routines.
template <typename _BidirectionalIterator, typename _Distance,
    typename _Compare>
void __merge_without_buffer(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last,
    _Distance __len1, _Distance __len2,
    _Compare __comp)
{
    if (__len1 == 0 || __len2 == 0)
        return;

    if (__len1 + __len2 == 2) {
        if (__comp(__middle, __first))
            std::iter_swap(__first, __middle);
        return;
    }

    _BidirectionalIterator __first_cut = __first;
    _BidirectionalIterator __second_cut = __middle;
    _Distance __len11 = 0;
    _Distance __len22 = 0;
    if (__len1 > __len2) {
        __len11 = __len1 / 2;
        std::advance(__first_cut, __len11);
        __second_cut
            = std::__lower_bound(__middle, __last, *__first_cut,
                __gnu_cxx::__ops::__iter_comp_val(__comp));
        __len22 = std::distance(__middle, __second_cut);
    } else {
        __len22 = __len2 / 2;
        std::advance(__second_cut, __len22);
        __first_cut
            = std::__upper_bound(__first, __middle, *__second_cut,
                __gnu_cxx::__ops::__val_comp_iter(__comp));
        __len11 = std::distance(__first, __first_cut);
    }

    _BidirectionalIterator __new_middle
        = std::rotate(__first_cut, __middle, __second_cut);
    standardlib::__merge_without_buffer(__first, __first_cut, __new_middle,
        __len11, __len22, __comp);
    standardlib::__merge_without_buffer(__new_middle, __second_cut, __last,
        __len1 - __len11, __len2 - __len22, __comp);
}

template <typename _BidirectionalIterator, typename _Compare>
void __inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last,
    _Compare __comp)
{
    typedef typename std::iterator_traits<_BidirectionalIterator>::value_type
        _ValueType;
    typedef typename std::iterator_traits<_BidirectionalIterator>::difference_type
        _DistanceType;
    typedef std::_Temporary_buffer<_BidirectionalIterator, _ValueType> _TmpBuf;

    if (__first == __middle || __middle == __last)
        return;

    const _DistanceType __len1 = std::distance(__first, __middle);
    const _DistanceType __len2 = std::distance(__middle, __last);

    // __merge_adaptive will use a buffer for the smaller of
    // [first,middle) and [middle,last).
    _TmpBuf __buf(__first, std::min(__len1, __len2));

    if (__buf.begin() == 0)
        standardlib::__merge_without_buffer(__first, __middle, __last, __len1, __len2, __comp);
    else
        standardlib::__merge_adaptive(__first, __middle, __last, __len1, __len2, __buf.begin(),
            _DistanceType(__buf.size()), __comp);
}

/// This is a helper function for the __merge_sort_loop routines.
template <typename _InputIterator, typename _OutputIterator,
    typename _Compare>
_OutputIterator
__move_merge(_InputIterator __first1, _InputIterator __last1,
    _InputIterator __first2, _InputIterator __last2,
    _OutputIterator __result, _Compare __comp)
{
    while (__first1 != __last1 && __first2 != __last2) {
        if (__comp(__first2, __first1)) {
            *__result = _GLIBCXX_MOVE(*__first2);
            ++__first2;
        } else {
            *__result = _GLIBCXX_MOVE(*__first1);
            ++__first1;
        }
        ++__result;
    }
    return _GLIBCXX_MOVE3(__first2, __last2,
        _GLIBCXX_MOVE3(__first1, __last1,
            __result));
}

template <typename _RandomAccessIterator1, typename _RandomAccessIterator2,
    typename _Distance, typename _Compare>
void __merge_sort_loop(_RandomAccessIterator1 __first,
    _RandomAccessIterator1 __last,
    _RandomAccessIterator2 __result, _Distance __step_size,
    _Compare __comp)
{
    const _Distance __two_step = 2 * __step_size;

    while (__last - __first >= __two_step) {
        __result = standardlib::__move_merge(__first, __first + __step_size,
            __first + __step_size,
            __first + __two_step,
            __result, __comp);
        __first += __two_step;
    }
    __step_size = std::min(_Distance(__last - __first), __step_size);

    standardlib::__move_merge(__first, __first + __step_size,
        __first + __step_size, __last, __result, __comp);
}

template <typename _RandomAccessIterator, typename _Distance,
    typename _Compare>
void __chunk_insertion_sort(_RandomAccessIterator __first,
    _RandomAccessIterator __last,
    _Distance __chunk_size, _Compare __comp)
{
    while (__last - __first >= __chunk_size) {
        standardlib::__insertion_sort(__first, __first + __chunk_size, __comp);
        __first += __chunk_size;
    }
    standardlib::__insertion_sort(__first, __last, __comp);
}

enum { _S_chunk_size = 7 };

template <typename _RandomAccessIterator, typename _Pointer, typename _Compare>
void __merge_sort_with_buffer(_RandomAccessIterator __first,
    _RandomAccessIterator __last,
    _Pointer __buffer, _Compare __comp)
{
    typedef typename std::iterator_traits<_RandomAccessIterator>::difference_type
        _Distance;

    const _Distance __len = __last - __first;
    const _Pointer __buffer_last = __buffer + __len;

    _Distance __step_size = _S_chunk_size;
    standardlib::__chunk_insertion_sort(__first, __last, __step_size, __comp);

    while (__step_size < __len) {
        standardlib::__merge_sort_loop(__first, __last, __buffer,
            __step_size, __comp);
        __step_size *= 2;
        standardlib::__merge_sort_loop(__buffer, __buffer_last, __first,
            __step_size, __comp);
        __step_size *= 2;
    }
}

template <typename _RandomAccessIterator, typename _Pointer,
    typename _Distance, typename _Compare>
void __stable_sort_adaptive(_RandomAccessIterator __first,
    _RandomAccessIterator __last,
    _Pointer __buffer, _Distance __buffer_size,
    _Compare __comp)
{
    const _Distance __len = (__last - __first + 1) / 2;
    const _RandomAccessIterator __middle = __first + __len;
    if (__len > __buffer_size) {
        standardlib::__stable_sort_adaptive(__first, __middle, __buffer,
            __buffer_size, __comp);
        standardlib::__stable_sort_adaptive(__middle, __last, __buffer,
            __buffer_size, __comp);
    } else {
        standardlib::__merge_sort_with_buffer(__first, __middle, __buffer, __comp);
        standardlib::__merge_sort_with_buffer(__middle, __last, __buffer, __comp);
    }

    standardlib::__merge_adaptive(__first, __middle, __last,
        _Distance(__middle - __first),
        _Distance(__last - __middle),
        __buffer, __buffer_size,
        __comp);
}

/// This is a helper function for the stable sorting routines.
template <typename _RandomAccessIterator, typename _Compare>
void __inplace_stable_sort(_RandomAccessIterator __first,
    _RandomAccessIterator __last, _Compare __comp)
{
    if (__last - __first < 15) {
        standardlib::__insertion_sort(__first, __last, __comp);
        return;
    }
    _RandomAccessIterator __middle = __first + (__last - __first) / 2;
    standardlib::__inplace_stable_sort(__first, __middle, __comp);
    standardlib::__inplace_stable_sort(__middle, __last, __comp);
    standardlib::__merge_without_buffer(__first, __middle, __last,
        __middle - __first,
        __last - __middle,
        __comp);
}

/**
   *  @brief Merges two sorted ranges.
   *  @ingroup sorting_algorithms
   *  @param  __first1  An iterator.
   *  @param  __first2  Another iterator.
   *  @param  __last1   Another iterator.
   *  @param  __last2   Another iterator.
   *  @param  __result  An iterator pointing to the end of the merged range.
   *  @param  __comp    A functor to use for comparisons.
   *  @return   An output iterator equal to @p __result + (__last1 - __first1)
   *            + (__last2 - __first2).
   *
   *  Merges the ranges @p [__first1,__last1) and @p [__first2,__last2) into
   *  the sorted range @p [__result, __result + (__last1-__first1) +
   *  (__last2-__first2)).  Both input ranges must be sorted, and the
   *  output range must not overlap with either of the input ranges.
   *  The sort is @e stable, that is, for equivalent elements in the
   *  two ranges, elements from the first range will always come
   *  before elements from the second.
   *
   *  The comparison function should have the same effects on ordering as
   *  the function used for the initial sort.
  */
  template<typename _InputIterator1, typename _InputIterator2,
	   typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
	  _InputIterator2 __first2, _InputIterator2 __last2,
	  _OutputIterator __result, _Compare __comp)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
	    typename std::iterator_traits<_InputIterator1>::value_type>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
	    typename std::iterator_traits<_InputIterator2>::value_type>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
	    typename std::iterator_traits<_InputIterator2>::value_type,
	    typename std::iterator_traits<_InputIterator1>::value_type>)
      __glibcxx_requires_sorted_set_pred(__first1, __last1, __first2, __comp);
      __glibcxx_requires_sorted_set_pred(__first2, __last2, __first1, __comp);
      __glibcxx_requires_irreflexive_pred2(__first1, __last1, __comp);
      __glibcxx_requires_irreflexive_pred2(__first2, __last2, __comp);

      return _GLIBCXX_STD_A::__merge(__first1, __last1,
				__first2, __last2, __result,
				__gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
		  _Compare __comp)
    {
      typedef typename std::iterator_traits<_RandomAccessIterator>::value_type
	_ValueType;
      typedef typename std::iterator_traits<_RandomAccessIterator>::difference_type
	_DistanceType;
      typedef std::_Temporary_buffer<_RandomAccessIterator, _ValueType> _TmpBuf;

      if (__first == __last)
	return;

      // __stable_sort_adaptive sorts the range in two halves,
      // so the buffer only needs to fit half the range at once.
      _TmpBuf __buf(__first, (__last - __first + 1) / 2);

      if (__buf.begin() == 0)
	standardlib::__inplace_stable_sort(__first, __last, __comp);
      else
	standardlib::__stable_sort_adaptive(__first, __last, __buf.begin(),
				    _DistanceType(__buf.size()), __comp);
    }

    /**
   *  @brief Sort the elements of a sequence, preserving the relative order
   *         of equivalent elements.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @return  Nothing.
   *
   *  Sorts the elements in the range @p [__first,__last) in ascending order,
   *  such that for each iterator @p i in the range @p [__first,__last-1),
   *  @p *(i+1)<*i is false.
   *
   *  The relative ordering of equivalent elements is preserved, so any two
   *  elements @p x and @p y in the range @p [__first,__last) such that
   *  @p x<y is false and @p y<x is false will have the same relative
   *  ordering after calling @p stable_sort().
  */
  template<typename _RandomAccessIterator>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
	    _RandomAccessIterator>)
      __glibcxx_function_requires(_LessThanComparableConcept<
	    typename std::iterator_traits<_RandomAccessIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);
      __glibcxx_requires_irreflexive(__first, __last);

      standardlib::__stable_sort(__first, __last,
				    __gnu_cxx::__ops::__iter_less_iter());
    }

  /**
   *  @brief Sort the elements of a sequence using a predicate for comparison,
   *         preserving the relative order of equivalent elements.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @param  __comp    A comparison functor.
   *  @return  Nothing.
   *
   *  Sorts the elements in the range @p [__first,__last) in ascending order,
   *  such that for each iterator @p i in the range @p [__first,__last-1),
   *  @p __comp(*(i+1),*i) is false.
   *
   *  The relative ordering of equivalent elements is preserved, so any two
   *  elements @p x and @p y in the range @p [__first,__last) such that
   *  @p __comp(x,y) is false and @p __comp(y,x) is false will have the same
   *  relative ordering after calling @p stable_sort().
  */
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
		_Compare __comp)
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
	    _RandomAccessIterator>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
	    typename std::iterator_traits<_RandomAccessIterator>::value_type,
	    typename std::iterator_traits<_RandomAccessIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);
      __glibcxx_requires_irreflexive_pred(__first, __last, __comp);

      standardlib::__stable_sort(__first, __last,
				    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

// stable_sort
} // namespace std
