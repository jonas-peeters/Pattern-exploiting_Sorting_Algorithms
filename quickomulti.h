#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#include <emmintrin.h> //SSE2
#include <immintrin.h> //AVX, AVX2, AVX-512
#include <nmmintrin.h> //SSE4.2
#include <pmmintrin.h> //SSE3
#include <smmintrin.h> //SSE4.1
#include <xmmintrin.h> //for SSE

void swap(int *a, int *b);
void insertionSortOptimized(int array[], int n);
void sort_quick_multix4_h(int array[], int low, int high, int tmp[]);
void sort_quick_optimized(int array[], int low, int high);
uint32_t hsum_8x32(__m256i v);
int x[2];

void partition_quick_multi(int array[], int low, int high, int targets[],
                           int tmp[]) {
  int size = high - low;
  __m256i pivots = _mm256_loadu_si256((__m256i *)&array[low]);

  int i = low;

  for (int j = low; j < high; j++) {
    __m256i currentValue = _mm256_set1_epi32(array[j]);
    __m256i compares = _mm256_cmpgt_epi32(pivots, currentValue);

    int index = 8 + hsum_8x32(compares);
    tmp[targets[index]] = array[j];
    targets[index] += 1;
  }

  int arrayIndex = low;

  for (int index = 0; index < 9; index++) {
    int j = index * size;
    for (; j < targets[index] - 7; j += 8) {
      _mm256_storeu_si256((__m256i *)&array[arrayIndex],
                          _mm256_loadu_si256((__m256i *)&tmp[j]));
      arrayIndex += 8;
    }
    for (; j < targets[index]; j++) {
      array[arrayIndex] = tmp[j];
      arrayIndex++;
    }
    targets[index] -= index * size;
  }
  // printf("Array ");
  // for (int index = 0; index < 40; index++) {
  //   printf("%d ", array[index]);
  // }
  // printf("\n");
}

void sort_quick_multi_h(int array[], int low, int high, int tmp[]) {
  // printf("Sorting from %d to %d\n", low, high);
  if (low < high) {
    if (high - low > 50) {
      int size = high - low + 1;
      int pivots[9] = {0,        size * 1, size * 2, size * 3, size * 4,
                       size * 5, size * 6, size * 7, size * 8};
      partition_quick_multi(array, low, high + 1, pivots, tmp);

      int start = low;

      for (int index = 0; index < 9; index++) {
        int end = start + pivots[index];
        sort_quick_multi_h(array, start, end - 1, tmp);
        start = end;
      }
    } else {
      sort_quick_optimized(array, low, high);
      // insertionSortOptimized(array + low, high - low + 1);
    }
  }
}

//int tmp[9000000];

void sort_quick_multi(int array[], int low, int high) {
  int *tmp = (int *) malloc(sizeof(int32_t) * (high - low) * 9);
  sort_quick_multi_h(array, low, high, tmp);
  free(tmp);
}
